<!DOCTYPE html>





    

    

    

    

<html lang="zh-cn"><head>
    <meta charset="utf-8" />
    <title>【字符串】KMP算法 | whutd blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Documentation, Hugo, Hugo Theme, Bootstrap" />
    <meta name="author" content="Colin Wilson - Lotus Labs" />
    <meta name="email" content="support@aigis.uk" />
    <meta name="website" content="https://lotusdocs.dev" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="https://whutd.github.io/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="https://whutd.github.io/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="https://whutd.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://whutd.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://whutd.github.io/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="https://whutd.github.io/site.webmanifest">
<meta property="og:title" content="【字符串】KMP算法" />
<meta property="og:description" content="作用 link用于快速快速查找模式串（子串）pattern在主串（母串）main中出现的位置。
注意，此处是匹配子串的要求，而子串是连续的
原理 link前置知识：前缀函数 link对于一个字符串，将它 不包含自身的前后缀（称为真前后缀） 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 最长匹配真前后缀的长度，此过程记为函数$π$
例如：对于字符串 $s=$ATAATA
含有真前缀为ATAAT ATAA ATA AT A ∅
含有真后缀为TAATA AATA ATA TA A ∅
匹配的前后缀有ATA，A，∅，长度分别为$3、1、0$
则字符串ATAATA的$π$值为$3$
然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是前缀函数。
字符串ATAATA的前缀函数数组如下

  
      
          下标 $i$
          0
          1
          2
          3
          4
          5
      
  
  
      
          前缀字符串
          A
          AT
          ATA
          ATAA
          ATAAT
          ATAATA
      
      
          $π[i]$
          $0$
          $0$
          $1$
          $1$
          $2$
          $3$
      
  

即$π[i]$就是子串 $s[0&hellip;i]$ 最长匹配真前后缀的长度
kmp原理 link如果将主串main和模式串pattern以一个特殊字符#链接在一起
并计算这个字符串的前缀函数，如果存在$π[i]$等于pattern的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与pattern完全相同。
设main=AGCATAATAATTAA，pattern=ATAATA，则合并串s=ATAATA#AGCATAATAATTAA

  
      
          合并串
          A
          T
          A
          A
          T
          A
          #
          A
          G
          C
          A
          T
          A
          A
          T
          A
          A
          T
          T
          A
          A
      
  
  
      
          $i$
          0
          1
          2
          3
          4
          5
          6
          7
          8
          9
          10
          11
          12
          13
          14
          15
          16
          17
          18
          19
          20
      
      
          $π[i]$
          $0$
          $0$
          $1$
          $1$
          $2$
          $3$
          $0$
          $1$
          $0$
          $0$
          $1$
          $2$
          $3$
          $4$
          $5$
          $6$
          $4$
          $5$
          $0$
          $1$
          $1$
      
  

可以看到$π[15]=6$，的确$s[0&hellip;i]=$ATAATA#AGCATAATA,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whutd.github.io/docs/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95/" /><meta property="og:image" content="https://whutd.github.io/opengraph/card-base-2_hu_327f07baaaa24c31.png"/><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2025-02-18T20:27:39+08:00" />
<meta property="article:modified_time" content="2025-02-18T20:27:39+08:00" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://whutd.github.io/opengraph/card-base-2_hu_327f07baaaa24c31.png"/>
<meta name="twitter:title" content="【字符串】KMP算法"/>
<meta name="twitter:description" content="作用 link用于快速快速查找模式串（子串）pattern在主串（母串）main中出现的位置。
注意，此处是匹配子串的要求，而子串是连续的
原理 link前置知识：前缀函数 link对于一个字符串，将它 不包含自身的前后缀（称为真前后缀） 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 最长匹配真前后缀的长度，此过程记为函数$π$
例如：对于字符串 $s=$ATAATA
含有真前缀为ATAAT ATAA ATA AT A ∅
含有真后缀为TAATA AATA ATA TA A ∅
匹配的前后缀有ATA，A，∅，长度分别为$3、1、0$
则字符串ATAATA的$π$值为$3$
然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是前缀函数。
字符串ATAATA的前缀函数数组如下

  
      
          下标 $i$
          0
          1
          2
          3
          4
          5
      
  
  
      
          前缀字符串
          A
          AT
          ATA
          ATAA
          ATAAT
          ATAATA
      
      
          $π[i]$
          $0$
          $0$
          $1$
          $1$
          $2$
          $3$
      
  

即$π[i]$就是子串 $s[0&hellip;i]$ 最长匹配真前后缀的长度
kmp原理 link如果将主串main和模式串pattern以一个特殊字符#链接在一起
并计算这个字符串的前缀函数，如果存在$π[i]$等于pattern的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与pattern完全相同。
设main=AGCATAATAATTAA，pattern=ATAATA，则合并串s=ATAATA#AGCATAATAATTAA

  
      
          合并串
          A
          T
          A
          A
          T
          A
          #
          A
          G
          C
          A
          T
          A
          A
          T
          A
          A
          T
          T
          A
          A
      
  
  
      
          $i$
          0
          1
          2
          3
          4
          5
          6
          7
          8
          9
          10
          11
          12
          13
          14
          15
          16
          17
          18
          19
          20
      
      
          $π[i]$
          $0$
          $0$
          $1$
          $1$
          $2$
          $3$
          $0$
          $1$
          $0$
          $0$
          $1$
          $2$
          $3$
          $4$
          $5$
          $6$
          $4$
          $5$
          $0$
          $1$
          $1$
      
  

可以看到$π[15]=6$，的确$s[0&hellip;i]=$ATAATA#AGCATAATA,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。"/>

    
        <link rel="alternate" type="application/atom+xml" title="Atom feed for whutd blog" href="/index.xml" />
    
    
    
            
                
                <script type="text/javascript" src="https://whutd.github.io/docs/js/flexsearch.bundle.min.f5159d5a2151ffbb653996ec17eaff7da4e04c286bd879fc41839d36a5586f3f20eaead0b6089de48f9adc669cdee771.js" integrity="sha384-9RWdWiFR/7tlOZbsF&#43;r/faTgTChr2Hn8QYOdNqVYbz8g6urQtgid5I&#43;a3Gac3udx" crossorigin="anonymous"></script>
                
        
    
    

    <link rel="stylesheet" href="/docs/scss/style.min.eef4206ae93758d6264b799b9c42da3c206c0b60cd73c152b53fd06e3dfda39797074b78982d6e911cd47ca5fc7acef1.css" integrity="sha384-7vQgauk3WNYmS3mbnELaPCBsC2DNc8FStT/Qbj39o5eXB0t4mC1ukRzUfKX8es7x"crossorigin="anonymous">
    <link rel="stylesheet" href="/docs/scss/katex.min.2d71e8cb3e099a45f865f21236cd9454c17a49188dbae11e85a0e9b3f53ee8b58ba076719642b60e6c6a385bd82f6c0e.css" integrity="sha384-LXHoyz4JmkX4ZfISNs2UVMF6SRiNuuEehaDps/U&#43;6LWLoHZxlkK2DmxqOFvYL2wO"crossorigin="anonymous">
    
    
        
        <script src="/docs/js/katex.min.29c00f3c13ecd528102ceaaf01c03b5dd697260b163f2fc975b60c129d6f157babddb6d399eb4fc8876b0708fcf9ba83.js" integrity="sha384-KcAPPBPs1SgQLOqvAcA7XdaXJgsWPy/JdbYMEp1vFXur3bbTmetPyIdrBwj8&#43;bqD"defer></script>
    <script src="/docs/js/auto-render.min.37bbffecf63ad080846fcb85afc455064d24048a73a0b9475c9ccf86b0ba4f8dcb0aa2047db27ac1bf94af5c6cc4b2e3.js" integrity="sha384-N7v/7PY60ICEb8uFr8RVBk0kBIpzoLlHXJzPhrC6T43LCqIEfbJ6wb&#43;Ur1xsxLLj"defer></script>
    
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.getElementById("content"), {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
    
    </head>
<body>
        <div class="content">
            <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                        
                        <li class="current">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95/">
                                
                                【字符串】KMP算法
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB/">
                                
                                ARP攻击
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/example-page/">
                                
                                Example Page
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/bigintcalc/">
                                
                                BigIntcalc
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/godan/">
                                
                                
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/">
                                
                                
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/whutd%E6%8E%A8%E6%96%870x00-----%E6%BC%AB%E8%B0%88sql/">
                                
                                
                            </a>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                    <main class="page-content bg-transparent">
                        
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
            </ul>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>


                            <div class="container-fluid">
                                <div class="layout-spacing">
                                    
                                        <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">【字符串】KMP算法</span>
                <meta itemprop="position" content='2' />
            </li>
        
    </ul>
</nav></div>
                                    
                                    <div class="row flex-xl-nowrap">
                                        
                                        <div class="docs-toc col-xl-3    d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#作用">作用</a></li>
    <li><a href="#原理">原理</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#代码实现">代码实现</a></li>
    <li><a href="#复杂度分析">复杂度分析</a></li>
    <li><a href="#相关题目">相关题目</a>
      <ul>
        <li><a href="#洛谷p3375-模版kmp"><a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375 【模版】KMP</a></a></li>
      </ul>
    </li>
  </ul>
</nav>
    </toc></div>
                                        
                                        
                                        <div class="docs-toc-mobile    d-print-none d-xl-none">
                                            <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                                Table of Contents
                                            </button>
<nav id="toc-mobile">
  <ul class="dropdown-menu">
    <li><a href="#作用">作用</a></li>
    <li><a href="#原理">原理</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#代码实现">代码实现</a></li>
    <li><a href="#复杂度分析">复杂度分析</a></li>
    <li><a href="#相关题目">相关题目</a>
      <ul>
        <li><a href="#洛谷p3375-模版kmp"><a href="https://www.luogu.com.cn/problem/P3375">洛谷P3375 【模版】KMP</a></a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                                        <div class="docs-content col-12 col-xl-9 mt-0">
                                            <div class="mb-0 d-flex">
                                                
                                                <h1 class="content-title mb-0">
                                                    【字符串】KMP算法
                                                    
                                                </h1>
                                            </div>
                                            
                                            <div id="content" class="main-content" >
                                                
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <h2 id="作用">作用 <a href="#%e4%bd%9c%e7%94%a8" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>用于<strong>快速</strong>快速查找模式串（子串）<code>pattern</code>在主串（母串）<code>main</code>中出现的位置。</p>
<p>注意，此处是匹配子串的要求，而子串是连续的</p>
<h2 id="原理">原理 <a href="#%e5%8e%9f%e7%90%86" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><h4 id="前置知识前缀函数">前置知识：前缀函数 <a href="#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e5%89%8d%e7%bc%80%e5%87%bd%e6%95%b0" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>对于一个字符串，将它 <em>不包含自身的前后缀（称为真前后缀）</em> 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 <em>最长匹配真前后缀的长度</em>，此过程记为函数$π$</p>
<p>例如：对于字符串 $s=$<code>ATAATA</code>
含有真前缀为<code>ATAAT</code> <code>ATAA</code> <code>ATA</code> <code>AT</code> <code>A</code> <code>∅</code>
含有真后缀为<code>TAATA</code> <code>AATA</code> <code>ATA</code> <code>TA</code> <code>A</code> <code>∅</code>
匹配的前后缀有<code>ATA</code>，<code>A</code>，<code>∅</code>，长度分别为$3、1、0$
则字符串<code>ATAATA</code>的$π$值为$3$</p>
<p>然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是<strong>前缀函数</strong>。</p>
<p>字符串<code>ATAATA</code>的前缀函数数组如下</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">下标 $i$</th>
          <th style="text-align: center">0</th>
          <th style="text-align: center">1</th>
          <th style="text-align: center">2</th>
          <th style="text-align: center">3</th>
          <th style="text-align: center">4</th>
          <th style="text-align: center">5</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">前缀字符串</td>
          <td style="text-align: center"><code>A</code></td>
          <td style="text-align: center"><code>AT</code></td>
          <td style="text-align: center"><code>ATA</code></td>
          <td style="text-align: center"><code>ATAA</code></td>
          <td style="text-align: center"><code>ATAAT</code></td>
          <td style="text-align: center"><code>ATAATA</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$π[i]$</td>
          <td style="text-align: center">$0$</td>
          <td style="text-align: center">$0$</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$2$</td>
          <td style="text-align: center">$3$</td>
      </tr>
  </tbody>
</table>
<p>即$π[i]$就是子串 $s[0&hellip;i]$ 最长匹配真前后缀的长度</p>
<h4 id="kmp原理">kmp原理 <a href="#kmp%e5%8e%9f%e7%90%86" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>如果将主串<code>main</code>和模式串<code>pattern</code>以一个特殊字符<code>#</code>链接在一起
并计算这个字符串的前缀函数，如果存在$π[i]$等于<code>pattern</code>的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与<code>pattern</code>完全相同。</p>
<p>设<code>main</code>=<code>AGCATAATAATTAA</code>，<code>pattern</code>=<code>ATAATA</code>，则合并串<code>s</code>=<code>ATAATA#AGCATAATAATTAA</code></p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">合并串</th>
          <th>A</th>
          <th>T</th>
          <th>A</th>
          <th>A</th>
          <th>T</th>
          <th>A</th>
          <th>#</th>
          <th>A</th>
          <th>G</th>
          <th>C</th>
          <th>A</th>
          <th>T</th>
          <th>A</th>
          <th>A</th>
          <th>T</th>
          <th>A</th>
          <th>A</th>
          <th>T</th>
          <th>T</th>
          <th>A</th>
          <th>A</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$i$</td>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
          <td>4</td>
          <td>5</td>
          <td>6</td>
          <td>7</td>
          <td>8</td>
          <td>9</td>
          <td>10</td>
          <td>11</td>
          <td>12</td>
          <td>13</td>
          <td>14</td>
          <td>15</td>
          <td>16</td>
          <td>17</td>
          <td>18</td>
          <td>19</td>
          <td>20</td>
      </tr>
      <tr>
          <td style="text-align: center">$π[i]$</td>
          <td>$0$</td>
          <td>$0$</td>
          <td>$1$</td>
          <td>$1$</td>
          <td>$2$</td>
          <td>$3$</td>
          <td>$0$</td>
          <td>$1$</td>
          <td>$0$</td>
          <td>$0$</td>
          <td>$1$</td>
          <td>$2$</td>
          <td>$3$</td>
          <td>$4$</td>
          <td>$5$</td>
          <td>$6$</td>
          <td>$4$</td>
          <td>$5$</td>
          <td>$0$</td>
          <td>$1$</td>
          <td>$1$</td>
      </tr>
  </tbody>
</table>
<p>可以看到$π[15]=6$，的确$s[0&hellip;i]=$<code>ATAATA#AGCATAATA</code>,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。</p>
<p>用$m$表示<code>pattern</code>的长度，则如果在某一位置 $i$ 有 $pi[i]=m$ 成立，则字符串<code>pattern</code>在字符串<code>main</code>的 $i-(m-1)-(m+1)=i-2m$处出现。</p>


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pi[N<span style="color:#f92672">+</span>M];
</span></span><span style="display:flex;"><span>string s<span style="color:#f92672">=</span>pattern<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;#&#39;</span><span style="color:#f92672">+</span>main;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span>main.size(),m<span style="color:#f92672">=</span>pattern.size();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>s.size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pi[i]<span style="color:#f92672">==</span>m){
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;模式串在主串的%d处出现</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i<span style="color:#f92672">-</span>m<span style="color:#f92672">-</span>m);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h4 id="πi的计算">$π[i]$的计算 <a href="#%cf%80i%e7%9a%84%e8%ae%a1%e7%ae%97" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>假设$0$~$π[i-1]$已经求出,记 $len=π[i-1]$，则$s[0&hellip;len-1]==s[i-len&hellip;i-1]$。</p>
<h6 id="如果-sislen">如果 s[i]==s[len] <a href="#%e5%a6%82%e6%9e%9c-sislen" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h6><p>则 $s[0&hellip;len]==s[i-len&hellip;i]$
所以 $π[i]=len+1$
<!-- raw HTML omitted --></p>
<h6 id="如果-sislen-1">如果 s[i]!=s[len] <a href="#%e5%a6%82%e6%9e%9c-sislen-1" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h6><p>则$s[0&hellip;len]！=s[i-len&hellip;i]$</p>
<p>由于$len$是子串 $s[0&hellip;i-1]$ <strong>最长</strong>匹配真前后缀的长度，但是可能存在仅次于$len$的<strong>第二长</strong>匹配真前后缀长度$len2$,使得当$s[i]==s[len2]$时，$s[0&hellip;len2]==s[i-len2&hellip;i]$。</p>
<p>





  



  
</p>
<p>所以我们需要比较$s[i]$和$s[len2]$,当$s[i]==s[len2]$时，$π[i]=len2+1$</p>
<p>当$s[i]!=s[len2]$时，寻找<strong>第三长</strong>匹配真前后缀长度 $len3$</p>
<p>$$
\overbrace{\underbrace{s_0}<em>{len3}<del>\underset{\text{len3}}{s_1}}^{len2}</del>\overset{\text{len2}}{s_2}<del>s_3</del>s_4~\dots~\overbrace{s</em>{i-2}~\underbrace{s_{i-1}}_{len3}}^{len2}~s_i
$$</p>
<p>比较$s[i]$和$s[len3]$,当$s[i]==s[len3]$时，$π[i]=len3+1$</p>
<p>以此类推，每次都寻找下一个长度的匹配真前后缀长度pi_next，一直直到$π$最小即 $len=0$</p>
<p>用代码写为</p>


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pi[N<span style="color:#f92672">+</span>M];
</span></span><span style="display:flex;"><span>pi[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//第一个字符不存在真前缀
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>s.size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len<span style="color:#f92672">=</span>pi[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(len <span style="color:#f92672">&amp;&amp;</span> s[i]<span style="color:#f92672">!=</span>s[len]){
</span></span><span style="display:flex;"><span>        len<span style="color:#f92672">=</span>pi_next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s[i]<span style="color:#f92672">==</span>s[len])pi[i]<span style="color:#f92672">=</span>len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h4 id="pi_next的计算">$pi$_$next$的计算 <a href="#pi_next%e7%9a%84%e8%ae%a1%e7%ae%97" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>当$s[len]!=s[i]$且$s[len2]==s[i]$时
$∵len==π[i-1]$
$∴s[0&hellip;len-1]==s[i-len&hellip;i-1]$</p>
<p>$$
\overbrace{s_0 ~ s_1 ~ {s_2} ~ s_3}^{len} ~ \overset{\text{len}}{s_4} ~ \dots ~ \overbrace{s_{i-4} ~ s_{i-3} ~ s_{i-2} ~ s_{i-1}}^{len} ~ s_{i}
$$</p>
<p>$∴s[len-len2&hellip;len-1]==s[i-len2&hellip;i-1]$</p>
<p>$$
\overbrace{s_0 ~ s_1 ~ \underbrace{{s_2} ~ s_3}<em>{len2}}^{len} ~ \overset{\text{len}}{s_4} ~ \dots ~ \overbrace{s</em>{i-4} ~ s_{i-3} ~ \underbrace{s_{i-2} ~ s_{i-1}}<em>{len2}}^{len} ~ s</em>{i}
$$</p>
<p>$∵len2==π_{next}[i-1]$
$∴s[0&hellip;len2-1]==s[i-len2&hellip;i-1]$</p>
<p>$$
\overbrace{\underbrace{s_0 ~ s_1}<em>{len2} ~ {s_2} ~ s_3}^{len} ~ \overset{\text{len}}{s_4} ~ \dots ~ \overbrace{s</em>{i-4} ~ s_{i-3} ~ \underbrace{s_{i-2} ~ s_{i-1}}<em>{len2}}^{len} ~ s</em>{i}
$$</p>
<p>$∴s[0&hellip;len2-1]==s[len-len2&hellip;len-1]$</p>
<p>$$
\overbrace{\underbrace{s_0 ~ s_1}<em>{len2} ~ \underbrace{{s_2} ~ s_3}</em>{len2}}^{len} ~ \overset{\text{len}}{s_4} ~ \dots ~ \overbrace{s_{i-4} ~ s_{i-3} ~ s_{i-2} ~ s_{i-1}}^{len} ~ s_{i}
$$</p>
<p>于是，$s[0&hellip;len-1]$中前$len2$个字符与后$len2$个字符相同，这就是这段区间最长的匹配前后缀。</p>
<p>$len2=π[len-1]$</p>
<p>显然我们可以得到一个关于$len$的转移方程$len_i=π[len_{i-1}]$</p>
<p>通过循环代码写为：</p>


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(len <span style="color:#f92672">&amp;&amp;</span> s[i]<span style="color:#f92672">!=</span>s[len]){
</span></span><span style="display:flex;"><span>        len<span style="color:#f92672">=</span>pi[len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="代码实现">代码实现 <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>最后，我们可以得到kmp算法的简洁代码</p>


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pi[N]; <span style="color:#75715e">// pi[i]表示第i个前缀 最长匹配真前后缀 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>string s <span style="color:#f92672">=</span> pattern <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">+</span> main;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> main.size(), m <span style="color:#f92672">=</span> pattern.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> pi[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查找最长匹配的真前后缀
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(len <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> s[len]){
</span></span><span style="display:flex;"><span>        len <span style="color:#f92672">=</span> pi[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s[i] <span style="color:#f92672">==</span> s[len]){
</span></span><span style="display:flex;"><span>        pi[i] <span style="color:#f92672">=</span> len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果找到完全匹配，输出起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(pi[i]<span style="color:#f92672">==</span>m){
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;模式串在主串的%d处出现</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i<span style="color:#f92672">-</span>m<span style="color:#f92672">-</span>m);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="复杂度分析">复杂度分析 <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>主循环从$i = 1$到$s.size() - 1$遍历整个字符串$s$，其中$s$是由模式串、分隔符和主串组成的。因此，此循环最多执行$s.size()$次。</p>
<p>在每次迭代中，有一个内部的$while$循环，用来回溯寻找最长匹配真前后缀。虽然看起来像是嵌套循环导致了二次方的时间复杂度，但实际上每个字符被比较的次数是有限制的。具体来说，因为$len$每次都会减少至少$1$，且在整个过程中只能增加$s.size()$次，所以整体来看，内层的$while$循环不会超过外层循环的次数。这意味着构造部分匹配表的过程总共需要$O(n+m)$的时间，其中$n$是字符串$main$的长度，$m$是字符串$pattern$的长度。</p>
<p>时间复杂度为 $O(n+m)$</p>
<p>而 $\pi$ 数组需要开至少$n+m+1的$大小，空间复杂度为 $O(n+m)$</p>
<h2 id="相关题目">相关题目 <a href="#%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><h3 id="洛谷p3375-模版kmp"><a href="https://www.luogu.com.cn/problem/P3375" rel="external" target="_blank">洛谷P3375 【模版】KMP<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a> <a href="#%e6%b4%9b%e8%b0%b7p3375-%e6%a8%a1%e7%89%88kmp" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><h4 id="题目描述">题目描述 <a href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。<br>
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。</p>
<p>定义一个字符串 $s$ 的 border 为 $s$ 的一个<strong>非 $s$ 本身</strong>的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。<br>
对于 $s_2$，你还需要求出对于其每个前缀 $s&rsquo;$ 的最长 border $t&rsquo;$ 的长度。</p>
<h4 id="输入格式">输入格式 <a href="#%e8%be%93%e5%85%a5%e6%a0%bc%e5%bc%8f" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>第一行为一个字符串，即为 $s_1$。<br>
第二行为一个字符串，即为 $s_2$。</p>
<h4 id="输出格式">输出格式 <a href="#%e8%be%93%e5%87%ba%e6%a0%bc%e5%bc%8f" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>首先输出若干行，每行一个整数，<strong>按从小到大的顺序</strong>输出 $s_2$ 在 $s_1$ 中出现的位置。<br>
最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。</p>
<h5 id="样例输入-1">样例输入 #1 <a href="#%e6%a0%b7%e4%be%8b%e8%be%93%e5%85%a5-1" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h5>

    
    <pre tabindex="0"><code>ABABABC
ABA</code></pre>
<h5 id="样例输出-1">样例输出 #1 <a href="#%e6%a0%b7%e4%be%8b%e8%be%93%e5%87%ba-1" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h5>

    
    <pre tabindex="0"><code>1
3
0 0 1</code></pre>
<h4 id="分析">分析 <a href="#%e5%88%86%e6%9e%90" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4><p>此题为模版题，其中要输出的 border 长度即为 $pi$ 数组</p>
<h4 id="代码">代码 <a href="#%e4%bb%a3%e7%a0%81" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h4>

    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000000</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pi[N]; <span style="color:#75715e">// pi[i]表示第i个前缀 最长匹配真前后缀 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    string main, pattern;
</span></span><span style="display:flex;"><span>    cin <span style="color:#f92672">&gt;&gt;</span> main <span style="color:#f92672">&gt;&gt;</span> pattern;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个新的字符串s，用于存储pattern、分隔符&#39;#&#39;以及main
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string s <span style="color:#f92672">=</span> pattern <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">+</span> main;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> main.size(), m <span style="color:#f92672">=</span> pattern.size();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> pi[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 查找最长匹配的真前后缀
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(len <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> s[len]){
</span></span><span style="display:flex;"><span>            len <span style="color:#f92672">=</span> pi[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(s[i] <span style="color:#f92672">==</span> s[len]){
</span></span><span style="display:flex;"><span>            pi[i] <span style="color:#f92672">=</span> len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果找到完全匹配，输出起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(pi[i] <span style="color:#f92672">==</span> m){
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> (i <span style="color:#f92672">-</span> m <span style="color:#f92672">-</span> m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 输出模式字符串部分的pi数组值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) printf(<span style="color:#e6db74">&#34;%d &#34;</span>, pi[i]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}   
</span></span></code></pre></div>

    </div>

    

    
                                            </div>
                                            <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap flex-row-reverse">
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/docs/arp%E6%94%BB%E5%87%BB/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">ARP攻击 <i class="material-icons align-middle">navigate_next</i></p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
            </div>
        </div>

        
        
        <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
        
        

        
        




    
    
    






    

    <script src="/docs/js/bootstrap.c7927bdd82eceb076739257add3f4b0e11379da037c07d5c7110daeb6de0e3edcb2de867604550f88815157e4ec4ddb7.js" integrity="sha384-x5J73YLs6wdnOSV63T9LDhE3naA3wH1ccRDa623g4&#43;3LLehnYEVQ&#43;IgVFX5OxN23"defer></script>


    <script type="text/javascript" src="https://whutd.github.io/docs/js/bundle.min.4b07706b1da436c9600e641a8cf51af20b3e497ead85e0d0af7552a0314e8e317dc63bb69d12c072092518621478900d.js" integrity="sha384-Swdwax2kNslgDmQajPUa8gs&#43;SX6theDQr3VSoDFOjjF9xju2nRLAcgklGGIUeJAN" crossorigin="anonymous" defer></script>

        

        
        <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/docs\/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95\/",
                title: "【字符串】KMP算法",
                description: "作用 link用于快速快速查找模式串（子串）pattern在主串（母串）main中出现的位置。\n注意，此处是匹配子串的要求，而子串是连续的\n原理 link前置知识：前缀函数 link对于一个字符串，将它 不包含自身的前后缀（称为真前后缀） 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 最长匹配真前后缀的长度，此过程记为函数$π$\n例如：对于字符串 $s=$ATAATA 含有真前缀为ATAAT ATAA ATA AT A ∅ 含有真后缀为TAATA AATA ATA TA A ∅ 匹配的前后缀有ATA，A，∅，长度分别为$3、1、0$ 则字符串ATAATA的$π$值为$3$\n然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是前缀函数。\n字符串ATAATA的前缀函数数组如下\n下标 $i$ 0 1 2 3 4 5 前缀字符串 A AT ATA ATAA ATAAT ATAATA $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ 即$π[i]$就是子串 $s[0…i]$ 最长匹配真前后缀的长度\nkmp原理 link如果将主串main和模式串pattern以一个特殊字符#链接在一起 并计算这个字符串的前缀函数，如果存在$π[i]$等于pattern的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与pattern完全相同。\n设main=AGCATAATAATTAA，pattern=ATAATA，则合并串s=ATAATA#AGCATAATAATTAA\n合并串 A T A A T A # A G C A T A A T A A T T A A $i$ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ $0$ $1$ $0$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $4$ $5$ $0$ $1$ $1$ 可以看到$π[15]=6$，的确$s[0…i]=$ATAATA#AGCATAATA,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。\n",
                content: "作用 link用于快速快速查找模式串（子串）pattern在主串（母串）main中出现的位置。\n注意，此处是匹配子串的要求，而子串是连续的\n原理 link前置知识：前缀函数 link对于一个字符串，将它 不包含自身的前后缀（称为真前后缀） 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 最长匹配真前后缀的长度，此过程记为函数$π$\n例如：对于字符串 $s=$ATAATA 含有真前缀为ATAAT ATAA ATA AT A ∅ 含有真后缀为TAATA AATA ATA TA A ∅ 匹配的前后缀有ATA，A，∅，长度分别为$3、1、0$ 则字符串ATAATA的$π$值为$3$\n然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是前缀函数。\n字符串ATAATA的前缀函数数组如下\n下标 $i$ 0 1 2 3 4 5 前缀字符串 A AT ATA ATAA ATAAT ATAATA $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ 即$π[i]$就是子串 $s[0…i]$ 最长匹配真前后缀的长度\nkmp原理 link如果将主串main和模式串pattern以一个特殊字符#链接在一起 并计算这个字符串的前缀函数，如果存在$π[i]$等于pattern的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与pattern完全相同。\n设main=AGCATAATAATTAA，pattern=ATAATA，则合并串s=ATAATA#AGCATAATAATTAA\n合并串 A T A A T A # A G C A T A A T A A T T A A $i$ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ $0$ $1$ $0$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $4$ $5$ $0$ $1$ $1$ 可以看到$π[15]=6$，的确$s[0…i]=$ATAATA#AGCATAATA,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。\n用$m$表示pattern的长度，则如果在某一位置 $i$ 有 $pi[i]=m$ 成立，则字符串pattern在字符串main的 $i-(m-1)-(m+1)=i-2m$处出现。\nint pi[N+M]; string s=pattern+'#'+main; int n=main.size(),m=pattern.size(); for(int i=1;i\u003cs.size();i++){ if(pi[i]==m){ printf(\"模式串在主串的%d处出现\\n\",i-m-m); } } $π[i]$的计算 link假设$0$~$π[i-1]$已经求出,记 $len=π[i-1]$，则$s[0…len-1]==s[i-len…i-1]$。\n如果 s[i]==s[len] link则 $s[0…len]==s[i-len…i]$ 所以 $π[i]=len+1$ 如果 s[i]!=s[len] link则$s[0…len]！=s[i-len…i]$\n由于$len$是子串 $s[0…i-1]$ 最长匹配真前后缀的长度，但是可能存在仅次于$len$的第二长匹配真前后缀长度$len2$,使得当$s[i]==s[len2]$时，$s[0…len2]==s[i-len2…i]$。\n所以我们需要比较$s[i]$和$s[len2]$,当$s[i]==s[len2]$时，$π[i]=len2+1$\n当$s[i]!=s[len2]$时，寻找第三长匹配真前后缀长度 $len3$\n$$ \\overbrace{\\underbrace{s_0}{len3}\\underset{\\text{len3}}{s_1}}^{len2}\\overset{\\text{len2}}{s_2}s_3s_4~\\dots~\\overbrace{s{i-2}~\\underbrace{s_{i-1}}_{len3}}^{len2}~s_i $$\n比较$s[i]$和$s[len3]$,当$s[i]==s[len3]$时，$π[i]=len3+1$\n以此类推，每次都寻找下一个长度的匹配真前后缀长度pi_next，一直直到$π$最小即 $len=0$\n用代码写为\nint pi[N+M]; pi[0]=0;//第一个字符不存在真前缀 for(int i=1;i\u003cs.size();i++){ int len=pi[i-1]; while(len \u0026\u0026 s[i]!=s[len]){ len=pi_next; } if(s[i]==s[len])pi[i]=len+1; } $pi$_$next$的计算 link当$s[len]!=s[i]$且$s[len2]==s[i]$时 $∵len==π[i-1]$ $∴s[0…len-1]==s[i-len…i-1]$\n$$ \\overbrace{s_0 ~ s_1 ~ {s_2} ~ s_3}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s_{i-4} ~ s_{i-3} ~ s_{i-2} ~ s_{i-1}}^{len} ~ s_{i} $$\n$∴s[len-len2…len-1]==s[i-len2…i-1]$\n$$ \\overbrace{s_0 ~ s_1 ~ \\underbrace{{s_2} ~ s_3}{len2}}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s{i-4} ~ s_{i-3} ~ \\underbrace{s_{i-2} ~ s_{i-1}}{len2}}^{len} ~ s{i} $$\n$∵len2==π_{next}[i-1]$ $∴s[0…len2-1]==s[i-len2…i-1]$\n$$ \\overbrace{\\underbrace{s_0 ~ s_1}{len2} ~ {s_2} ~ s_3}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s{i-4} ~ s_{i-3} ~ \\underbrace{s_{i-2} ~ s_{i-1}}{len2}}^{len} ~ s{i} $$\n$∴s[0…len2-1]==s[len-len2…len-1]$\n$$ \\overbrace{\\underbrace{s_0 ~ s_1}{len2} ~ \\underbrace{{s_2} ~ s_3}{len2}}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s_{i-4} ~ s_{i-3} ~ s_{i-2} ~ s_{i-1}}^{len} ~ s_{i} $$\n于是，$s[0…len-1]$中前$len2$个字符与后$len2$个字符相同，这就是这段区间最长的匹配前后缀。\n$len2=π[len-1]$\n显然我们可以得到一个关于$len$的转移方程$len_i=π[len_{i-1}]$\n通过循环代码写为：\nwhile(len \u0026\u0026 s[i]!=s[len]){ len=pi[len-1]; } 代码实现 link最后，我们可以得到kmp算法的简洁代码\nint pi[N]; // pi[i]表示第i个前缀 最长匹配真前后缀 的长度 string s = pattern + '#' + main; int n = main.size(), m = pattern.size(); for(int i = 1; i \u003c s.size(); i++){ int len = pi[i - 1]; // 查找最长匹配的真前后缀 while(len \u0026\u0026 s[i] != s[len]){ len = pi[len - 1]; } if(s[i] == s[len]){ pi[i] = len + 1; // 如果找到完全匹配，输出起始位置 if(pi[i]==m){ printf(\"模式串在主串的%d处出现\\n\",i-m-m); } } } 复杂度分析 link主循环从$i = 1$到$s.size() - 1$遍历整个字符串$s$，其中$s$是由模式串、分隔符和主串组成的。因此，此循环最多执行$s.size()$次。\n在每次迭代中，有一个内部的$while$循环，用来回溯寻找最长匹配真前后缀。虽然看起来像是嵌套循环导致了二次方的时间复杂度，但实际上每个字符被比较的次数是有限制的。具体来说，因为$len$每次都会减少至少$1$，且在整个过程中只能增加$s.size()$次，所以整体来看，内层的$while$循环不会超过外层循环的次数。这意味着构造部分匹配表的过程总共需要$O(n+m)$的时间，其中$n$是字符串$main$的长度，$m$是字符串$pattern$的长度。\n时间复杂度为 $O(n+m)$\n而 $\\pi$ 数组需要开至少$n+m+1的$大小，空间复杂度为 $O(n+m)$\n相关题目 link洛谷P3375 【模版】KMP link题目描述 link给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。\n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n定义一个字符串 $s$ 的 border 为 $s$ 的一个非 $s$ 本身的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。\n对于 $s_2$，你还需要求出对于其每个前缀 $s’$ 的最长 border $t’$ 的长度。\n输入格式 link第一行为一个字符串，即为 $s_1$。\n第二行为一个字符串，即为 $s_2$。\n输出格式 link首先输出若干行，每行一个整数，按从小到大的顺序输出 $s_2$ 在 $s_1$ 中出现的位置。\n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。\n样例输入 #1 link ABABABC\rABA 样例输出 #1 link 1\r3\r0 0 1 分析 link此题为模版题，其中要输出的 border 长度即为 $pi$ 数组\n代码 link #include using namespace std; const int N = 2000000 + 10; int pi[N]; // pi[i]表示第i个前缀 最长匹配真前后缀 的长度 int main(){ string main, pattern; cin \u003e\u003e main \u003e\u003e pattern; // 创建一个新的字符串s，用于存储pattern、分隔符'#'以及main string s = pattern + '#' + main; int n = main.size(), m = pattern.size(); for(int i = 1; i \u003c s.size(); i++){ int len = pi[i - 1]; // 查找最长匹配的真前后缀 while(len \u0026\u0026 s[i] != s[len]){ len = pi[len - 1]; } if(s[i] == s[len]){ pi[i] = len + 1; // 如果找到完全匹配，输出起始位置 if(pi[i] == m){ cout \u003c\u003c (i - m - m + 1) \u003c\u003c endl; } } } // 输出模式字符串部分的pi数组值 for(int i = 0; i \u003c m; i++) printf(\"%d \", pi[i]); return 0; } "
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/docs\/arp%E6%94%BB%E5%87%BB\/",
                title: "ARP攻击",
                description: "0x00 OSI模型 link在开放系统互连（OSI）参考模型中，网络工作被划分为七个层次。各层之间并不直接进行交互，而是仅通过层接口（Layer Interface）实现彼此间的通信。\nIP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。\n0x01 ARP协议 link地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。\n0x02 ARP攻击 link1.表现 link一般情况下，受到ARP攻击的计算机会出现两种现象：\n不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。\n计算机不能正常上网，出现网络中断的症状。\n除此之外，用户可能还会遭遇信息泄露的情况。\n2.原理 linkARP协议是TCP/IP协议组的一个协议，这个协议是建立在局域网上主机相互信任的基础上的，局域网中的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性并直接将其记入本机ARP缓存。ARP缓存表采用的是机械制原理，如果表中的某一列长时间不使用，就会被删除。也就是说ARP的缓存表是可以被更改的。表中的IP地址和MAC地址也是随时可以修改，这样在局域网中很容易被ARP欺骗。\n在网络通信过程中，当客户机向外部网络发送数据包时，首先会借助ARP协议来获取网关的MAC地址。之后，客户机会将 IP 数据包封装在以太网帧中，并发送给该网关，由网关负责后续的转发工作。\n然而，网络环境并非绝对安全。当有恶意人员接入网络后，会对网络中的 ARP 流量进行监听。由于 ARP 地址解析请求采用广播的方式发送，网络中的所有参与者都能够接收到该请求，黑客自然也不例外。\n以 PC 解析网关 192.168.50.1 的 MAC 地址这一过程为例。当黑客嗅探到 ARP 请求后，可能会实施恶意行为。黑客会伪装成网关，伪造 ARP 应答信息来欺骗 PC。PC 在接收到 ARP 应答后，会将应答结果存储在 ARP 缓存中。由于 ARP 协议缺乏有效的校验机制，PC 很容易受到黑客的欺骗。需要注意的是，网关也会向 PC 发送真实的 ARP 应答。在此情况下，PC 会依据系统协议栈的规则来采信应答信息，而系统协议栈通常以最新接收到的应答作为有效信息。\n黑客在嗅探到 ARP 请求后，会持续发送虚假应答，总有一个虚假应答能够覆盖网关发送的真实应答，从而进入 PC 的 ARP 缓存表。这种攻击方式被称为 ARP 泛洪（ARP Flooding）。\n",
                content: "0x00 OSI模型 link在开放系统互连（OSI）参考模型中，网络工作被划分为七个层次。各层之间并不直接进行交互，而是仅通过层接口（Layer Interface）实现彼此间的通信。\nIP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。\n0x01 ARP协议 link地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。\n0x02 ARP攻击 link1.表现 link一般情况下，受到ARP攻击的计算机会出现两种现象：\n不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。\n计算机不能正常上网，出现网络中断的症状。\n除此之外，用户可能还会遭遇信息泄露的情况。\n2.原理 linkARP协议是TCP/IP协议组的一个协议，这个协议是建立在局域网上主机相互信任的基础上的，局域网中的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性并直接将其记入本机ARP缓存。ARP缓存表采用的是机械制原理，如果表中的某一列长时间不使用，就会被删除。也就是说ARP的缓存表是可以被更改的。表中的IP地址和MAC地址也是随时可以修改，这样在局域网中很容易被ARP欺骗。\n在网络通信过程中，当客户机向外部网络发送数据包时，首先会借助ARP协议来获取网关的MAC地址。之后，客户机会将 IP 数据包封装在以太网帧中，并发送给该网关，由网关负责后续的转发工作。\n然而，网络环境并非绝对安全。当有恶意人员接入网络后，会对网络中的 ARP 流量进行监听。由于 ARP 地址解析请求采用广播的方式发送，网络中的所有参与者都能够接收到该请求，黑客自然也不例外。\n以 PC 解析网关 192.168.50.1 的 MAC 地址这一过程为例。当黑客嗅探到 ARP 请求后，可能会实施恶意行为。黑客会伪装成网关，伪造 ARP 应答信息来欺骗 PC。PC 在接收到 ARP 应答后，会将应答结果存储在 ARP 缓存中。由于 ARP 协议缺乏有效的校验机制，PC 很容易受到黑客的欺骗。需要注意的是，网关也会向 PC 发送真实的 ARP 应答。在此情况下，PC 会依据系统协议栈的规则来采信应答信息，而系统协议栈通常以最新接收到的应答作为有效信息。\n黑客在嗅探到 ARP 请求后，会持续发送虚假应答，总有一个虚假应答能够覆盖网关发送的真实应答，从而进入 PC 的 ARP 缓存表。这种攻击方式被称为 ARP 泛洪（ARP Flooding）。\n一旦受害者的 ARP 缓存表被黑客篡改，其网络通信将完全处于黑客的控制之下。以 PC 为例，原本需要通过网关转发至外部网络的 IP 数据包，会被黑客劫持，导致 PC 无法访问外部网络，出现网络中断的情况。但这种攻击方式不仅难以获取实际利益，还容易被发现。\n为了保持攻击的隐蔽性，黑客通常会充当中间人，将劫持的数据包继续转发至真正的网关。要实现这一目的，黑客需要同时欺骗网关和 PC。\nPC 被黑客欺骗后，会将外出数据包发送给黑客，而黑客则会将这些数据包转发至网关，进而使其进入互联网，形成类似上述绿色路径的通信过程。与此同时，网关也会被黑客欺骗，误认为黑客就是 PC，从而将发往 PC 的数据包发送给黑客，黑客再将数据包转发给 PC，形成类似上述红色路径的通信过程。\n当 PC 的网络流量经过黑客的控制范围时，黑客便可以实施各种恶意行为。黑客可以对 PC 的网络速率进行限制，严重影响其网络使用体验。更为严重的是，黑客还可以对 PC 的数据包进行分析，从中窃取敏感信息，如账号和密码等。特别是当 PC 使用非加密的超文本传输协议（HTTP）与外部进行通信时，其传输的数据将完全暴露在黑客面前。因此，在不安全的网络环境中，必须使用超文本传输安全协议（HTTPS）来保障数据的安全性。\n3.防御对策 link在路由和终端上同时进行 IP 地址和 MAC 地址的绑定，相当于人工管理 ARP 缓存，自行维护 IP 地址和 MAC 地址的对应关系。既然将 ARP 协议弃之不用，黑客就无法发起攻击了。这个方案虽然可以奏效，但维护非常繁琐。换个网卡或 IP 地址，都需要重新修改配置。当流动电脑临时接入时，也要即时进行绑定，费时费力。\n使用 PPPoE 协议对网络流量进行二次封装，为每个用户都分配账号密码，上网时必须通过认证。这样 ARP 报文在一个认证的通道中传输，也就不会遭受攻击了。 但 PPPoE 也不是完美的，由于二次封装的存在，传输效率会打些折扣。更严重的是，PPPoE 方式下局域网内无法互访。如果局域网内需要部署文件服务器、打印机，就有麻烦了。\nDHCP snooping，网络设备可借由DHCP保留网络上各电脑的MAC地址，在伪造的ARP数据包发出时即可侦测到。此方式已在一些厂牌的网络设备产品所支持。\n有一些软件可监听网络上的ARP回应，若侦测出有不正常变动时可发送电子邮件通知管理者。例如UNIX平台的Arpwatch以及Windows上的XArp v2[2]或一些网络设备的Dynamic ARP inspection功能。\n其实最关键的一点在于，坚持使用 HTTPS 这样的加密协议。这样就算遭遇 ARP 劫持，信息也不会被窃取。在陌生的网络环境中，应该尽量不用 HTTP 这样的明文协议。\n"
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/docs\/example-page\/",
                title: "Example Page",
                description: "abababba\n",
                content: "abababba\n"
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/docs\/bigintcalc\/",
                title: "BigIntcalc",
                description: "朴素大整数算法的基本思想是模拟手算乘法，时间复杂度为O(n^2),而Karatsuba算法和FFT可以优化这一点",
                content: "大数乘法优化的几点方法 link 悲剧地发现看不懂前面的推文后立志要写出只要是上过课的都能懂的文章。请懂的同学通过目录去了解自己有兴趣的内容，或者快速划过这篇推文。\n空间优化 link 压位 link 在获取大数字符串后需要以转换为整形存储，然而，如果数组里只存了1个数字未免有点浪费，所以我们可以进行压位操作，多存几个数字。以10进制存储的大数乘法运算一般压4位。 要注意的是，在例如 77x130=10010 的计算中，积在数组中的存储为[1，10]，输出结果就变成了110.为了避免这种结果，我们需要对输出格式进行一些处理： int BigNumber_print(int*c,int top)//c为逆序存放乘积的数组，top为最高位下标 { printf(\"%d\",c[top]);//最高位所在不能补零输出 for(int i=top-1;i\u003e=0;i--) { printf(\"%04d\",c[i]);//将结果右对齐输出，结果补零，效果如：10-\u003e0010 } return 0; } 事实上，为了全bit存储以及后续部分算法的使用，我们可以将大数以2进制存储，这就需要2个将10进制转化为2进制的输入函数与将2进制转化为10进制的输出函数。这里不多做赘述。 时间优化 link Karatsuba算法优化 link 先来做道竖式计算吧 link相信大家都做过这样的乘法列式计算题。 大数乘法的基本方法就是模拟手算乘法，简单，好想，空间复杂度小，时间复杂度为$O(n^2)$。 这个过程可以理解为： ($24\\times10 + 0\\times1) \\times (3\\times10 + 6\\times1 ) = 72\\times100 + (144+0)\\times10+(0+6)\\times1$ 需要计算的乘法有：24x3、24x6、0x3、0x6\n如果把上面的过程抽象为字符形式： ($a \\times x+b$)($c \\times x+d$)=$ac · x^2+ (ad+bc) \\times x+bd$ 那么为了得出结果，我们需要知道ac、ad、bc、bd这4个乘法运算结果。\n关键的地方到了。\n易知：(a-b)(c-d)=ac+bd-(ad+bc)，若用ac+bd-(a-b)(c-d)来表示(ad+bc)的话，只需要计算3个乘法运算结果：(a-b)(c-d)、ac、bd。\nKaratsuba算法的具体步骤 link理解了上面的内容后，下面介绍Karatsuba算法的具体步骤： 假设2个大数x、y的长度分别为p、q; 取$n=min\\lbrace p,q \\rbrace$; 将x、y表示为：$x=a·10^{n/2} + b；y=c·10^{n/2} + d$； 计算$(a-b)(c-d)、ac、bd$； 结果为：$ac·10^n+[ac+bd-(a-b)(c-d)]·10^{n/2}+bd$ Karatsuba算法的程序实现 link该算法可通过递归实现，需要提前写好大数加减算法。\n下面给出1个c++代码参考，来源CSDN。据编写者所说，由于没有考虑string类型的一些函数耗时，实际的运行效率是更低的。粘贴过来是因为觉得这个思路清晰，便于学习理解。仅作参考。\n// 简单乘法，一个数和个位数相乘求积； string multiply(const string\u0026 num1, char num2) { if (num2 == '0' || ISZERO(num1)) { return \"0\"; } int len = num1.size(); string product(len, '0'); int carry = 0; for (int i = len - 1; i \u003e= 0; --i) { int ret = CTOI(num1[i]) * CTOI(num2) + carry; product[len-i-1] = ITOC(ret % 10); carry = ret / 10; } if (carry != 0) product.push_back(ITOC(carry)); reverse(product.begin(), product.end()); return product; } // Karatsuba乘法 string karatsuba(const string\u0026 num1, const string\u0026 num2) { // 递归的简单情况 if (ISZERO(num1) || ISZERO(num2)) { return \"0\"; } if (num1.size() == 1 ) { return multiply(num2, num1[0]); } if (num2.size() == 1) { return multiply(num1, num2[0]); } int len1 = num1.size(); int len2 = num2.size(); int half = ((std::max)(len1, len2) + 1) / 2; // 步骤一:计算a, b, c, d string a = (len1 \u003e half) ? num1.substr(0, len1 - half) : \"0\"; string b = (len1 \u003e half) ? num1.substr(len1 - half, half) : num1; string c = (len2 \u003e half) ? num2.substr(0, len2 - half) : \"0\"; string d = (len2 \u003e half) ? num2.substr(len2 - half, half) : num2; // 步骤二：计算a*c、b*d、(a+b)*(c+d)-a*c-b*d string t0 = karatsuba(a,c); string t1 = karatsuba(b,d); string t2 = karatsuba(add(a, b), add(c, d)); string t3 = sub(sub(t2, t1), t0); // 步骤三：计算乘积结果 string nOffset(2 * half, '0'); string nHalfOffset(half, '0'); string product = add(add((t0 + nOffset), (t3 + nHalfOffset)), t1); return product; } 基于快速傅里叶变换FFT的优化 link 来做一道矩阵乘法吧 link假设有1道乘法计算：521 x 123 = ?，显然： $$521 = 5 \\times 10^2 + 2 \\times 10^1 + 1 \\times 10^0$$ $$123 = 1 \\times 10^2 + 2 \\times 10^1 + 3 \\times 10^0$$\n设x=10，就得到了2个多项式： $f(x) = 5 x^2 + 2 x^1 + 1 x^0$ $g(x) = 1 x^2 + 2 x^1 + 3 x^0$ 则：$h(x) = f(x)g(x) = a + bx^1 + c x^2 + d x^3 + e x^4$； 即$521 \\times 123 = abcde$\n$另取x = {1,2,3}$\n$ \\begin{vmatrix} a \u0026 b \u0026 c \u0026 d \u0026 e \\ \\end{vmatrix} \\times $ $ \\begin{vmatrix} 1 \u0026 1 \u0026 1\\\\ 1^1 \u0026 2^1 \u0026 3^1\\\\ 1^2 \u0026 2^2 \u0026 3^2\\\\ 1^3 \u0026 2^3 \u0026 3^3\\\\ 1^4 \u0026 2^4 \u0026 3^4 \\end{vmatrix}= \\begin{vmatrix} h(1) \u0026 h(2) \u0026 h(3) \\ \\end{vmatrix} $\n通过矩阵运算可得abcde结果（利用范德蒙德矩阵的相关性质） 看上去很神奇，但很遗憾，时间复杂度依然是$O(n^2)$，没有优化。\n为了解决这个问题，让我们重温一下复数的知识。\nFFT（快速傅里叶变换） link不知道大家还记不记得高中数学学过的复数的几何表示：$r(cos(t)+i \\times sin(t)$，复数的乘法可表示为模相乘，辐角相加。 若取$r=1，t=\\dfrac{2\\pi}{n}$，设该复数为$x_n$，易知函数$L(k)=x_4^k$（k为非负整数）是个周期函数，最小正周期为n。 当n=4，情况如下。 可以发现 $x_4^0 = 1 = -x_4^2，x_4^1 = i = -x_4^3$。\n同理设$x_8$，易得$x_4^i=x_8^2i,-x_8^i=x_8^{i+4}，x_4^0=-x_8^4$ $$设f(x) = a_0 x^0 +a_1 x^1 + a_2 x^2 + a_3 x^3 + a_4 x^4 + a_5 x^5 + a_6 x^6 + a_7 x^7，(x取 x_8^0 …… x_8^7)$$ $$设p1(x)=a_0 x^0+ a_2 x^1 + a_4 x^2+ a_6 x^3，p2(x)= a_1 x^0+a_3 x^1+a_5 x^2+ a_7 x^3$$ 则$f(x)=p1(x^2)+x·p2(x^2)$，$f(-x)=p1(x^2)-x·p2(x^2)$ （将多项式函数奇偶分离） 所以$f(x_8^i)=p1(x_4^i)+x_4^i·p2(x_4^{i^2})$，$f(x_8^{4+i})=p1(x_4^i)-x_4^i·p2(x_4^{i^2})（i 取0，1，2，3）$ 成功实现用2个4项多项式表达8项多项式。而且，通过该等式，我们可以构造一种递归的算法，将每一个多项式分解为两项，而每一项又只需要$\\dfrac{n}{2}$计算量，不断递归。时间复杂度为$O(nlogn)$\n另：因为多项式是2个2个地分解的，所以一般需要确保多项式项数说2的整次幂。不足的话就补充系数为零的项。\n这种对f(x)进行的变换就叫做FFT。\n程序实现 link 同样来源于CSDN，仅作参考。\n#include #include #include #include using namespace std; const double PI = acos(-1.0); // 递归实现FFT void fft(vector\u003ccomplex\u003cdouble\u003e\u003e\u0026 a, bool inv) { int n = a.size(); if (n == 1) { return; } //分治 vector\u003ccomplex\u003cdouble\u003e\u003e a0(n / 2), a1(n / 2); for (int i = 0, j = 0; i \u003c n; i += 2, j++) { a0[j] = a[i]; a1[j] = a[i + 1]; } fft(a0, inv); fft(a1, inv); //FFT double angle = 2 * PI / n * (inv ? -1 : 1); complex\u003cdouble\u003e w(1), wn(cos(angle), sin(angle)); for (int i = 0; i \u003c n / 2; i++) { a[i] = a0[i] + w * a1[i]; a[i + n / 2] = a0[i] - w * a1[i]; w *= wn; } } // FFT乘法 vector\u003cint\u003e multiply(vector\u003cint\u003e a, vector\u003cint\u003e b) { int n = 1; // 将多项式的项数变为2的整数次幂 while (n \u003c a.size() + b.size()) { n *= 2; } a.resize(n), b.resize(n); vector\u003ccomplex\u003cdouble\u003e\u003e c(n), d(n); for (int i = 0; i \u003c n; i++) { c[i] = complex\u003cdouble\u003e(a[i], 0); d[i] = complex\u003cdouble\u003e(b[i], 0); } // 求原多项式的FFT fft(c, false), fft(d, false); for (int i = 0; i \u003c n; i++) { c[i] *= d[i]; } // 求乘法结果的IFFT fft(c, true); // 将IFFT中与逆矩阵相差的1/n乘进去 vector\u003cint\u003e res(n); for (int i = 0; i \u003c n; i++) { res[i] = (int)(c[i].real() / n + 0.5); } // 处理进位 int carry = 0; for (int i = 0; i\u003c n; i++) { res[i] += carry; carry = res[i] / 10; res[i] %= 10; } // 去高位的0 while (res.size() \u003e 1 \u0026\u0026 res.back() == 0) { res.pop_back(); } return res; } // 将大整数字符串转换为vector vector\u003cint\u003e to_vector(string s) { vector\u003cint\u003e res; for (int i = s.size() - 1; i \u003e= 0; i--) { res.push_back(s[i] - '0'); } return res; } // 将vector转换为大整数字符串 string to_string(vector\u003cint\u003e a) { string res; for (int i = a.size() - 1; i \u003e= 0; i--) { res += to_string(a[i]); } return res; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vector\u003cint\u003e a = to_vector(s1), b = to_vector(s2); vector\u003cint\u003e c = multiply(a, b); cout \u003c\u003c to_string(c) \u003c\u003c endl; return 0; } "
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/docs\/",
                title: "Docs",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/docs\/godan\/",
                title: "",
                description: "XSS 漏洞分析与攻防技术 link1. 漏洞分析：XSS 漏洞的成因及攻击方式 linkXSS 漏洞的成因 linkXSS（Cross-Site Scripting）漏洞通常发生在 Web 应用程序未对用户输入进行充分的过滤或转义时。攻击者通过将恶意 JavaScript 代码嵌入到 Web 页面中，利用页面没有正确处理用户输入来执行恶意脚本，最终达到窃取用户信息、劫持会话、篡改页面内容等目的。\nXSS 漏洞的主要类型 link 反射型 XSS（Reflected XSS）\n攻击者将恶意脚本嵌入到 URL 或表单字段中，当用户访问该 URL 时，恶意脚本会立即在页面中反射执行。 示例：http://example.com/search?q= 存储型 XSS（Stored XSS）\n攻击者将恶意脚本存储在服务器端（如论坛评论区、用户帖子等），当其他用户访问存储的内容时，恶意脚本被执行。 示例：攻击者在评论区提交 ，其他用户查看该评论时脚本执行。 DOM 型 XSS（DOM-based XSS）\n攻击者通过操作网页上的 DOM 元素来触发脚本执行，而不是依赖服务器的响应。 示例：通过修改 window.location 或 document.location 注入恶意代码。 攻击方式 linkXSS 攻击的目标通常是：\n窃取 Cookies：攻击者通过脚本获取用户的 cookie 信息。 窃取会话：攻击者窃取会话标识符（如 Token），从而劫持用户会话。 篡改页面内容：修改页面 DOM，诱导用户点击恶意链接或输入信息。 劫持用户输入：通过恶意脚本记录用户的键盘输入或篡改表单数据。 2. 攻防技术介绍 link攻击手段 link Payload 编写技巧\n",
                content: "XSS 漏洞分析与攻防技术 link1. 漏洞分析：XSS 漏洞的成因及攻击方式 linkXSS 漏洞的成因 linkXSS（Cross-Site Scripting）漏洞通常发生在 Web 应用程序未对用户输入进行充分的过滤或转义时。攻击者通过将恶意 JavaScript 代码嵌入到 Web 页面中，利用页面没有正确处理用户输入来执行恶意脚本，最终达到窃取用户信息、劫持会话、篡改页面内容等目的。\nXSS 漏洞的主要类型 link 反射型 XSS（Reflected XSS）\n攻击者将恶意脚本嵌入到 URL 或表单字段中，当用户访问该 URL 时，恶意脚本会立即在页面中反射执行。 示例：http://example.com/search?q= 存储型 XSS（Stored XSS）\n攻击者将恶意脚本存储在服务器端（如论坛评论区、用户帖子等），当其他用户访问存储的内容时，恶意脚本被执行。 示例：攻击者在评论区提交 ，其他用户查看该评论时脚本执行。 DOM 型 XSS（DOM-based XSS）\n攻击者通过操作网页上的 DOM 元素来触发脚本执行，而不是依赖服务器的响应。 示例：通过修改 window.location 或 document.location 注入恶意代码。 攻击方式 linkXSS 攻击的目标通常是：\n窃取 Cookies：攻击者通过脚本获取用户的 cookie 信息。 窃取会话：攻击者窃取会话标识符（如 Token），从而劫持用户会话。 篡改页面内容：修改页面 DOM，诱导用户点击恶意链接或输入信息。 劫持用户输入：通过恶意脚本记录用户的键盘输入或篡改表单数据。 2. 攻防技术介绍 link攻击手段 link Payload 编写技巧\n脚本注入：常见的脚本 payload 如 或嵌套多层 HTML 元素，如 。 编码绕过：利用 URL 编码、十六进制编码、Base64 编码等方式绕过过滤机制。 DOM 操控：利用 document.write()、innerHTML 等方法注入恶意脚本。 免杀技术\n变种 Payload：通过字符替换、混淆、编码等技术绕过过滤器。 事件属性绕过：通过 onload、onerror、onclick 等事件属性注入脚本，如 。 DOM-based 绕过：通过注入脚本，使其通过 DOM 操作执行。 防御策略 link 输入验证与过滤\n严格对用户输入进行验证，禁止直接注入 发送恶意链接 将该链接发送给目标用户，诱导其点击。\n执行脚本 当用户点击该链接时，攻击者嵌入的脚本在用户的浏览器中执行，弹出警告框 alert(‘XSS’)。\n关键技术 URL 编码绕过：如果服务器对 \u003c 和 \u003e 进行了过滤，可以通过 URL 编码绕过。例如，\u003c 变成 %3C，\u003e 变成 %3E。 事件注入绕过：如果 "
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/docs\/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0\/",
                title: "",
                description: "RSA算法讲解 link 一、生成密钥的基本步骤 $\\textcircled {1}$ 寻找两个质数p q $\\textcircled {2}$ 两个质数相乘计算N N = p * q $\\textcircled {3}$ 使用欧拉函数计算T T = (p - 1)*(q - 1) $\\textcircled {4}$ 选择合适的公钥E (注意：E应该是一个质数，且不是T的因子) $\\textcircled {5}$ 计算生成私钥D , 其中D应当满足：（D * E）% T = 1\n经过上述操作，我们将得到公钥对（N, E）与私钥对(N, D),其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下： $$ 明文^E % N = 密文\\ 密文^D % N = 明文\\ $$ 接下来我将具体讲解每个步骤的原理。\n二、寻找质数p q\n随机数生成 int random_num() { srand(time(NULL)); int bai_num = (rand() % (600 - 300 + 1)) + 300; //int p = (rand() % (max_t - min_t + 1)) + min_t; int two_num = (rand() % (99 - 10 + 1)) + 10; int rad_num = bai_num * 100 + two_num; return rad_num; } 这里我们采用C语言的rand()函数，并且以时间为种子生成随机数，注意到这里我生成了两个随机数，原因是： 为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，很难保证生成的随机数的均匀分布（即每次生成的大随机数很接近），因此我将五位数的前三位和后两位分开随机生成，可以确保生成的随机数在所给区间里的均匀分配 判断生成的随机数是不是质数 这里我们采用Miller Rabin素性检验,主要原理是利用了质数必然满足费马小定理，也即质数一定满足费马小定理，但是满足费马小定理的可能是伪素数，但我们可以通过多次检验来降低出错概率 参考文献： Miller Rabin素性检验 代码如下： int miller_rabin_test(unsigned long long n, int k) { // 处理小数和偶数的情况 if (n \u003c= 1 || (n \u003e 2 \u0026\u0026 n % 2 == 0)) return 0; if (n \u003c= 3) return 1; // 将 n - 1 表示为 d * 2^r unsigned long long d = n - 1; int r = 0; while ((d \u0026 1) == 0) { d \u003e\u003e= 1; r++; } // 执行 k 次测试 for (int i = 0; i \u003c k; i++) { unsigned long long a = 2 + rand() % (n - 4); unsigned long long x = mod_pow(a, d, n); if (x == 1 || x == n - 1) continue; int j; for (j = 0; j \u003c r - 1; j++) { x = mod_pow(x, 2, n); if (x == n - 1) break; } if (j == r - 1) return 0; } return 1; } unsigned long long mod_pow(unsigned long long base, unsigned long long exp, unsigned long long mod) { unsigned long long result = 1; base = base % mod; while (exp \u003e 0) { if (exp % 2 == 1) result = (result * base) % mod; exp = exp \u003e\u003e 1; base = (base * base) % mod; } return result; } 通过以上办法我们成功找到了两个合适的质数p q\n",
                content: "RSA算法讲解 link 一、生成密钥的基本步骤 $\\textcircled {1}$ 寻找两个质数p q $\\textcircled {2}$ 两个质数相乘计算N N = p * q $\\textcircled {3}$ 使用欧拉函数计算T T = (p - 1)*(q - 1) $\\textcircled {4}$ 选择合适的公钥E (注意：E应该是一个质数，且不是T的因子) $\\textcircled {5}$ 计算生成私钥D , 其中D应当满足：（D * E）% T = 1\n经过上述操作，我们将得到公钥对（N, E）与私钥对(N, D),其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下： $$ 明文^E % N = 密文\\ 密文^D % N = 明文\\ $$ 接下来我将具体讲解每个步骤的原理。\n二、寻找质数p q\n随机数生成 int random_num() { srand(time(NULL)); int bai_num = (rand() % (600 - 300 + 1)) + 300; //int p = (rand() % (max_t - min_t + 1)) + min_t; int two_num = (rand() % (99 - 10 + 1)) + 10; int rad_num = bai_num * 100 + two_num; return rad_num; } 这里我们采用C语言的rand()函数，并且以时间为种子生成随机数，注意到这里我生成了两个随机数，原因是： 为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，很难保证生成的随机数的均匀分布（即每次生成的大随机数很接近），因此我将五位数的前三位和后两位分开随机生成，可以确保生成的随机数在所给区间里的均匀分配 判断生成的随机数是不是质数 这里我们采用Miller Rabin素性检验,主要原理是利用了质数必然满足费马小定理，也即质数一定满足费马小定理，但是满足费马小定理的可能是伪素数，但我们可以通过多次检验来降低出错概率 参考文献： Miller Rabin素性检验 代码如下： int miller_rabin_test(unsigned long long n, int k) { // 处理小数和偶数的情况 if (n \u003c= 1 || (n \u003e 2 \u0026\u0026 n % 2 == 0)) return 0; if (n \u003c= 3) return 1; // 将 n - 1 表示为 d * 2^r unsigned long long d = n - 1; int r = 0; while ((d \u0026 1) == 0) { d \u003e\u003e= 1; r++; } // 执行 k 次测试 for (int i = 0; i \u003c k; i++) { unsigned long long a = 2 + rand() % (n - 4); unsigned long long x = mod_pow(a, d, n); if (x == 1 || x == n - 1) continue; int j; for (j = 0; j \u003c r - 1; j++) { x = mod_pow(x, 2, n); if (x == n - 1) break; } if (j == r - 1) return 0; } return 1; } unsigned long long mod_pow(unsigned long long base, unsigned long long exp, unsigned long long mod) { unsigned long long result = 1; base = base % mod; while (exp \u003e 0) { if (exp % 2 == 1) result = (result * base) % mod; exp = exp \u003e\u003e 1; base = (base * base) % mod; } return result; } 通过以上办法我们成功找到了两个合适的质数p q\n三、计算N以及T的值 这里我着重讲解以下欧拉函数 ==定义==： 对于一个正整数n， n的欧拉函数$\\phi(n)$表示小于等于n的与n互质的正整数个数。 ==性质1==： 如果n为质数，那么$\\phi(n) = n - 1$ ==性质2==： 如果p，q都为质数，那么$\\phi(p \\cdot q) = \\phi(p) \\times \\phi(q) = (p - 1) \\times (q - 1)$ ==性质3==： 若p为质数，则$\\phi(p^k) = p^k - p^{k-1}$\n四、选择公钥E 这里的公钥E一般是人为自己选择的，只需要确保E与T==互质==即可，一般不要太大\n五、计算私钥 ==引理1==： 辗转相除法（欧几里得算法）： $$ gcd(a,b) = gcd(b, a%b) = \\cdots $$ 其中gcd中第一个参数大于第二个参数 现在我们回到所要解决的问题： 计算生成私钥D , 其中D应当满足：（D * E）% T = 1，其中E和T我们已经在前面得到 将（D * E）% T = 1变形，有： E(已知)* D = k（未知）T + 1 对于这个问题，我们可以知道的是，对于不同的k，可能会有不同的D与之对应，但我们只需要找到一个最接近0的即可\n==引理2==： 拓展欧几里得算法如下 例子：给定正整数$a$, $b$（互质且默认a\u003eb）, 求满足$ax+by = 1$的解$x$和$y$(这里会发现和我们上述式子形式基本一致) 那么我们会有： $$ ax+by=1 = gcd(a, b) = gcd(b, a mod b) = bx’+ (amodb)y’ =bx’ + (a-b\\lfloor\\frac{a}{b}\\rfloor)y’\\ 整理一下，得到\\ ax+by = 1 和ay’ + b(x’ - \\lfloor\\frac{a}{b}\\rfloor y’) = 1 $$ 所以我们认为， $$ x = y’, y = x’ - \\lfloor\\frac{a}{b}\\rfloor y’ $$ 这里我们和欧几里得算法一样不断进行下去，最终会得到比较简单的结果，在根据递推关系求解出原问题。\n代码如下：\nvoid calculate(unsigned long long max, unsigned long long min) { if (min == 0) { // (1, 0) -\u003e (result[0] 系数大值) result[1] = 0; result[0] = 1; count--; } else { unsigned long long temp1 = result[0]; unsigned long long temp2 = result[1]; result[0] = temp2; result[1] = temp1 - (max / min) * temp2; count--; } //printf(\"*(%d, %d)*\", result[0], result[1]); if (count == 0) { return; } max = arr[count - 1][0]; min = arr[count - 1][1]; calculate(max, min); } 我们采用递归的方法计算，把每次计算结果存储在arr中。\n六、对信息的加密和解密 这里我主要介绍一个快速算模幂的算法：\nunsigned long long modular_exponentiation(unsigned long long base, unsigned long long exponent, unsigned long long modulus) { unsigned long long result = 1; base = base % modulus; // 更新底数为小于模数的值 while (exponent \u003e 0) { // 如果指数是奇数，乘上底数 if (exponent % 2 == 1) { result = (result * base) % modulus; } // 平方底数 base = (base * base) % modulus; // 整除指数 exponent = exponent / 2; } return result; } 用于解决明文和密文之间的转换\n"
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/docs\/whutd%E6%8E%A8%E6%96%870x00-----%E6%BC%AB%E8%B0%88sql\/",
                title: "",
                description: "漫谈SQL link 0x00 SQL是什么？有什么用？ link要谈谈SQL的定性，那我们就必需同时提到另一个概念”数据库“；当今时代数据爆炸，面对巨额的数据，我们创造了数据库这个在线的结构来处理，管理这些数据。而SQL就是一种结构化的数据库操作语言，它使得我们能够高效，准确的获取，修改，操作数据库中我们需要的数据。\n0x01：SQL基本处理与对应语法 link从上一个部分，我们可以把SQL分成以下几个部分\n1.DDL(Data Definition Language)数据定义语言，用来定义数据库对象(库 表 列…)\n2.DML(Data Manipulation Language)数据操作语言，用来操作数据库中的数据\n3.DCL(Data Control Language)数据控制语言，定义数据权限与安全问题\n4.DQL（Data Query Language）数据查询语言，查询数据\n我们一个一个来讲讲基本语法\n以下语法句子中关键字均采取大写处理\n1.DDL link库操作 link 创建数据库：CREATE DATABASE NAME；e.gCREATE DATABASE whustd，创建一个名为 whustd的数据库。如果这个数据已经存在，那么会报错。但是 CREATE DATABASE IF NOT EXISTS whustd，在名为 whustd 的数据库不存在时创建该库，这样可以避免报错。\n删除数据库：DROP DATABASE [IF EXISTS] NAME；e.g DROP DATABASE whustd，删除名为 WHUSTD 的数据库。如果这个数据库不存在，那么会报错。同理 DROP DATABASE IF EXISTS WHUSTD，就算 WHUSTD不存在，也不会的报错。\n修改数据库编码：ALTER DATABASE whustd CHARACTER SET utf8 修改数据库 WHUSTD 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都 不能使用中间的“-”，即 UTF-8 要书写为 UTF8。 修改编码一般是处理非英文内容的编译防止出现乱码。\n",
                content: "漫谈SQL link 0x00 SQL是什么？有什么用？ link要谈谈SQL的定性，那我们就必需同时提到另一个概念”数据库“；当今时代数据爆炸，面对巨额的数据，我们创造了数据库这个在线的结构来处理，管理这些数据。而SQL就是一种结构化的数据库操作语言，它使得我们能够高效，准确的获取，修改，操作数据库中我们需要的数据。\n0x01：SQL基本处理与对应语法 link从上一个部分，我们可以把SQL分成以下几个部分\n1.DDL(Data Definition Language)数据定义语言，用来定义数据库对象(库 表 列…)\n2.DML(Data Manipulation Language)数据操作语言，用来操作数据库中的数据\n3.DCL(Data Control Language)数据控制语言，定义数据权限与安全问题\n4.DQL（Data Query Language）数据查询语言，查询数据\n我们一个一个来讲讲基本语法\n以下语法句子中关键字均采取大写处理\n1.DDL link库操作 link 创建数据库：CREATE DATABASE NAME；e.gCREATE DATABASE whustd，创建一个名为 whustd的数据库。如果这个数据已经存在，那么会报错。但是 CREATE DATABASE IF NOT EXISTS whustd，在名为 whustd 的数据库不存在时创建该库，这样可以避免报错。\n删除数据库：DROP DATABASE [IF EXISTS] NAME；e.g DROP DATABASE whustd，删除名为 WHUSTD 的数据库。如果这个数据库不存在，那么会报错。同理 DROP DATABASE IF EXISTS WHUSTD，就算 WHUSTD不存在，也不会的报错。\n修改数据库编码：ALTER DATABASE whustd CHARACTER SET utf8 修改数据库 WHUSTD 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都 不能使用中间的“-”，即 UTF-8 要书写为 UTF8。 修改编码一般是处理非英文内容的编译防止出现乱码。\n常用数据类型 link int：整型\ndouble：浮点型，例如 double(5,2)表示最多 5 位，其中必须有 2 位小数，即最大值为 999.99；\ndecimal：泛型型，在表单线方面使用该类型，因为不会出现精度缺失问题；\nchar：固定长度字符串类型；(当输入的字符不够长度时会补空格)\nvarchar：固定长度字符串类型；\ntext：字符串类型；\nblob：字节类型；\ndate：日期类型，格式为：yyyy-MM-dd；\ntime：时间类型，格式为：hh:mm:ss\ntimestamp：时间戳类型；\n表操作 link CREATE TABLE 表名 (列名 列类型, 列名 列类型, ...... ); e.g\nCREATE TABLE whustd( ​\tsid CHAR(6), (sid:服务器安全标识，长度为固定6个字符，不足用空格补足（char）) ​\tsname VARCHAR(20), （sname 即名字，不用name是因为部分数据库的内容中name是保留字；varchar则是可变长度的字符串，最高不超过20即可 ） ​\tage INT, （年龄，整数形） ​\tgender VARCHAR(10) （性别，male/female） ); 查看表的结构 DESC 表名;\n删除表 DROP TABLE 表名;\n修改表 ALTER TABLE whustd ADD (classname varchar(100));\n添加列：给 whustd 表添加 classname 列\n修改列的数据类型： ALTER TABLE whustd MODIFY gender CHAR(2);\n修改 whustd 表的 gender 列类型为 CHAR(2)\nALTER TABLE whustd change gender sex CHAR(2);\n修改列名：修改 whustd 表的 gender 列名为 sex\nALTER TABLE whustd DROP classname;\n删除列：删除 whustd 表的 classname 列\nALTER TABLE whustd RENAME TO student;\n修改表名称：修改 whustd 表名称为 student\n2.DML link1.插入数据 link 语法 1： INSERT INTO 表名(列名 1,列名 2, …) ;\nINSERT INTO whustd(sid, sname,age,gender) VALUES('s_1001', 'zhangSan', 23, 'male');\n给sid,sname,age,gender赋值为’s_1001’, ‘zhangSan’, 23, ‘male’\nINSERT INTO whustd(sid, sname) VALUES('s_1001', 'zhangSan');\n同上\n语法 2： INSERT INTO 表名 VALUES(值 1,值 2,…);\n因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：\nINSERT INTO stu VALUES('s_1002', 'liSi', 32, 'female');\n按照sid, sname,age,gender默认顺序来赋值\n2.修改数据 link语法：\nUPDATE 表名 SET 列名 1=值 1, … 列名 n=值 n [WHERE 条件];\n例子\nUPDATE whustd SET sname=’zhangSanSan’, age=’32’, gender=’female’ WHERE sid=’s_1001’; UPDATE whustd SET sname=’liSi’, age=’20’**WHERE** age\u003e50 AND gender=’male’;(条件) UPDATE whustd SET sname=’wangWu’, age=’30’WHERE age\u003e60 OR gender=’female’; UPDATE whustd SET gender=’female’WHERE gender IS NULL UPDATE whustd SET age=age+1 WHERE sname=’zhaoLiu’; 3.删除数据 link 语法 1： DELETE FROM 表名 [WHERE 条件];\nDELETE FROM whustd WHERE sid=’s_1001’003B; DELETE FROM whustd WHERE sname=’chenQi’ OR age \u003e 30; DELETE FROM whustd; 语法 2： TRUNCATE TABLE 表名;\nTRUNCATE TABLE whustd;\n两者之间的区别： 虽然 TRUNCATE 和 DELETE 都可以删除表的所有记录，但有原理不同。DELETE的效率没有 TRUNCATE 高！\nTRUNCATE 其实属性 DDL 语句，因为它是先 DROP TABLE，再 CREATE TABLE。\n而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的\n3.DCL link1.创建用户 link语法：\nCREATE USER ‘用户名’@地址 IDENTIFIED BY '密码';\n这里这个地址表示主机标识，即用户可以从那些设备连接到数据库\nCREATE USER ‘user1’@localhost IDENTIFIED BY ‘123’;（创造一个用户，通过本地主机访问，密码为123） CREATE USER ‘user2’@’%’ IDENTIFIED BY ‘123’;（不限制访问设备） 2.给用户授权 link语法：\nGRANT 权限 1, … , 权限 n ON 数据库.* TO ‘用户名’@地址;\nGRANT *CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT* ON whustd.* TO 'user1'@localhost; GRANT ALL ON whustd.* TO user2@localhost; 3.撤销授权 link语法：\nREVOKE 权限 1, … , 权限 n ON 数据库.* FROM ‘用户名’@地址; 例如：\nREVOKE CREATE,ALTER,DROP ON whustd.* FROM 'user1'@localhost;\n4.查看用户权限 link语法：\nSHOW GRANTS FOR ‘用户名’@地址;\nSHOW GRANTS FOR 'user1'@localhost;\n5.删除用户 link语法：\nDROP USER ‘用户名’@地址;\nDROP USER ‘user1’@localhost;\n6.修改用户密码（以root身份） link语法 ：\nuse mysql; alter user '用户名'@localhost identified by '新密码'; 4.DQL link1.基础查询 link 查询所有列 SELECT * FROM 表名;\n(* ：通配符，表示所有列)\nSELECT * FROM whustd;\n查询指定列 SELECT 列名 1, 列名 2, …列名 n FROM 表名;\nSELECT sid, sname, age FROM whustd;\n2.条件查询 link 条件查询就是在查询时给出 WHERE 子句，在 WHERE 子句中可以使用如下运算符及关键字：\n=、!=、\u003c\u003e、\u003c、\u003c=、\u003e、\u003e=；\rBETWEEN…AND；\rIN(set)；\rIS NULL；\rAND；\rOR；\rNOT； 3.模糊查询 linkSELECT 字段 FROM 表 WHERE 某字段 Like 条件\n其中关于条件，SQL 提供了两种匹配模式：\n‘’%’’ ：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情 况下若是中文，请使用两个百分号（%%）表示。\n“_\"： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字 符长度语句。 .4.字段控制查询 link 给列名添加别名 SELECT *, oldname (AS) newname FROM whustd;\n给列起别名时，是可以省略 AS 关键字的：\nSELECT *, oldname newname FROM whustd;\n5.排序 link 查询所有学生记录，按年龄升序排序 SELECT * FROM whustd ORDER BY sage ASC; 或者\nSELECT * FROM whustd ORDER BY sage; 再或者查询所有学生记录，按年龄降序排序 SELECT * FROM whustd ORDER BY age DESC; 6.聚合函数 link聚合函数是用来做纵向运算的函数：\nCOUNT()：统计指定列不为 NULL 的记录行数；\nMAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\nMIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\nSUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为 0；\nAVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为 0；\nCOUNT：当需要纵向统计时可以使用 COUNT()。\nSUM 和 AVG：当需要纵向求和时使用 sum()函数。\n"
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
        
    </body>
</html>
