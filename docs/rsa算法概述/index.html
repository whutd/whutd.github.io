<!DOCTYPE html>





    

    

    

    

<html lang="zh-cn"><head>
    <meta charset="utf-8" />
    <title>RSA算法讲解 | whutd blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Documentation, Hugo, Hugo Theme, Bootstrap" />
    <meta name="author" content="Colin Wilson - Lotus Labs" />
    <meta name="email" content="support@aigis.uk" />
    <meta name="website" content="https://lotusdocs.dev" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="https://whutd.github.io/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="https://whutd.github.io/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="https://whutd.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://whutd.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://whutd.github.io/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="https://whutd.github.io/site.webmanifest">
<meta property="og:title" content="RSA算法讲解" />
<meta property="og:description" content="一、生成密钥的基本步骤
$\textcircled {1}$ 寻找两个质数p q
$\textcircled {2}$ 两个质数相乘计算N
N = p * q
$\textcircled {3}$ 使用欧拉函数计算T
T = (p - 1)*(q - 1)
$\textcircled {4}$ 选择合适的公钥E (注意：E应该是一个质数，且不是T的因子)
$\textcircled {5}$ 计算生成私钥D , 其中D应当满足：（D * E）% T = 1
经过上述操作，我们将得到公钥对（N, E）与私钥对(N, D),其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下：
$$
明文^E % N = 密文\
密文^D % N = 明文\
$$
接下来我将具体讲解每个步骤的原理。

二、寻找质数p q

随机数生成


    
    int random_num() {
    srand(time(NULL));
    int bai_num = (rand() % (600 - 300 &#43; 1)) &#43; 300;
    //int p = (rand() % (max_t - min_t &#43; 1)) &#43; min_t;
    int two_num = (rand() % (99 - 10 &#43; 1)) &#43; 10;
    int rad_num = bai_num * 100 &#43; two_num;
    return rad_num;
}
这里我们采用C语言的rand()函数，并且以时间为种子生成随机数，注意到这里我生成了两个随机数，原因是：
为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，很难保证生成的随机数的均匀分布（即每次生成的大随机数很接近），因此我将五位数的前三位和后两位分开随机生成，可以确保生成的随机数在所给区间里的均匀分配
判断生成的随机数是不是质数
这里我们采用Miller Rabin素性检验,主要原理是利用了质数必然满足费马小定理，也即质数一定满足费马小定理，但是满足费马小定理的可能是伪素数，但我们可以通过多次检验来降低出错概率
参考文献： Miller Rabin素性检验
代码如下：


    
    int miller_rabin_test(unsigned long long n, int k) {
 // 处理小数和偶数的情况
 if (n &lt;= 1 || (n &gt; 2 &amp;&amp; n % 2 == 0)) return 0;
 if (n &lt;= 3) return 1;

 // 将 n - 1 表示为 d * 2^r
 unsigned long long d = n - 1;
 int r = 0;
 while ((d &amp; 1) == 0) {
 	d &gt;&gt;= 1;
 	r&#43;&#43;;
 }

 // 执行 k 次测试
 for (int i = 0; i &lt; k; i&#43;&#43;) {
 	unsigned long long a = 2 &#43; rand() % (n - 4);
 	unsigned long long x = mod_pow(a, d, n);
 	if (x == 1 || x == n - 1) continue;

 	int j;
 	for (j = 0; j &lt; r - 1; j&#43;&#43;) {
 		x = mod_pow(x, 2, n);
 		if (x == n - 1) break;
 	}
 	if (j == r - 1) return 0;
 }
     return 1;
 }

 unsigned long long mod_pow(unsigned long long base, unsigned long long exp, unsigned long long mod) {
 unsigned long long result = 1;
 base = base % mod;
 while (exp &gt; 0) {
 	if (exp % 2 == 1)
 		result = (result * base) % mod;
 	exp = exp &gt;&gt; 1;
 	base = (base * base) % mod;
 }
 return result;
 }


通过以上办法我们成功找到了两个合适的质数p q" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whutd.github.io/docs/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/" /><meta property="og:image" content="https://whutd.github.io/opengraph/card-base-2_hu_45a46db3a6d81cbf.png"/><meta property="article:section" content="docs" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://whutd.github.io/opengraph/card-base-2_hu_45a46db3a6d81cbf.png"/>
<meta name="twitter:title" content="RSA算法讲解"/>
<meta name="twitter:description" content="一、生成密钥的基本步骤
$\textcircled {1}$ 寻找两个质数p q
$\textcircled {2}$ 两个质数相乘计算N
N = p * q
$\textcircled {3}$ 使用欧拉函数计算T
T = (p - 1)*(q - 1)
$\textcircled {4}$ 选择合适的公钥E (注意：E应该是一个质数，且不是T的因子)
$\textcircled {5}$ 计算生成私钥D , 其中D应当满足：（D * E）% T = 1
经过上述操作，我们将得到公钥对（N, E）与私钥对(N, D),其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下：
$$
明文^E % N = 密文\
密文^D % N = 明文\
$$
接下来我将具体讲解每个步骤的原理。

二、寻找质数p q

随机数生成


    
    int random_num() {
    srand(time(NULL));
    int bai_num = (rand() % (600 - 300 &#43; 1)) &#43; 300;
    //int p = (rand() % (max_t - min_t &#43; 1)) &#43; min_t;
    int two_num = (rand() % (99 - 10 &#43; 1)) &#43; 10;
    int rad_num = bai_num * 100 &#43; two_num;
    return rad_num;
}
这里我们采用C语言的rand()函数，并且以时间为种子生成随机数，注意到这里我生成了两个随机数，原因是：
为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，很难保证生成的随机数的均匀分布（即每次生成的大随机数很接近），因此我将五位数的前三位和后两位分开随机生成，可以确保生成的随机数在所给区间里的均匀分配
判断生成的随机数是不是质数
这里我们采用Miller Rabin素性检验,主要原理是利用了质数必然满足费马小定理，也即质数一定满足费马小定理，但是满足费马小定理的可能是伪素数，但我们可以通过多次检验来降低出错概率
参考文献： Miller Rabin素性检验
代码如下：


    
    int miller_rabin_test(unsigned long long n, int k) {
 // 处理小数和偶数的情况
 if (n &lt;= 1 || (n &gt; 2 &amp;&amp; n % 2 == 0)) return 0;
 if (n &lt;= 3) return 1;

 // 将 n - 1 表示为 d * 2^r
 unsigned long long d = n - 1;
 int r = 0;
 while ((d &amp; 1) == 0) {
 	d &gt;&gt;= 1;
 	r&#43;&#43;;
 }

 // 执行 k 次测试
 for (int i = 0; i &lt; k; i&#43;&#43;) {
 	unsigned long long a = 2 &#43; rand() % (n - 4);
 	unsigned long long x = mod_pow(a, d, n);
 	if (x == 1 || x == n - 1) continue;

 	int j;
 	for (j = 0; j &lt; r - 1; j&#43;&#43;) {
 		x = mod_pow(x, 2, n);
 		if (x == n - 1) break;
 	}
 	if (j == r - 1) return 0;
 }
     return 1;
 }

 unsigned long long mod_pow(unsigned long long base, unsigned long long exp, unsigned long long mod) {
 unsigned long long result = 1;
 base = base % mod;
 while (exp &gt; 0) {
 	if (exp % 2 == 1)
 		result = (result * base) % mod;
 	exp = exp &gt;&gt; 1;
 	base = (base * base) % mod;
 }
 return result;
 }


通过以上办法我们成功找到了两个合适的质数p q"/>

    
        <link rel="alternate" type="application/atom+xml" title="Atom feed for whutd blog" href="/index.xml" />
    
    
    
            
                
                <script type="text/javascript" src="https://whutd.github.io/docs/js/flexsearch.bundle.min.f5159d5a2151ffbb653996ec17eaff7da4e04c286bd879fc41839d36a5586f3f20eaead0b6089de48f9adc669cdee771.js" integrity="sha384-9RWdWiFR/7tlOZbsF&#43;r/faTgTChr2Hn8QYOdNqVYbz8g6urQtgid5I&#43;a3Gac3udx" crossorigin="anonymous"></script>
                
        
    
    

    <link rel="stylesheet" href="/docs/scss/style.min.eef4206ae93758d6264b799b9c42da3c206c0b60cd73c152b53fd06e3dfda39797074b78982d6e911cd47ca5fc7acef1.css" integrity="sha384-7vQgauk3WNYmS3mbnELaPCBsC2DNc8FStT/Qbj39o5eXB0t4mC1ukRzUfKX8es7x"crossorigin="anonymous">
    <link rel="stylesheet" href="/docs/scss/katex.min.2d71e8cb3e099a45f865f21236cd9454c17a49188dbae11e85a0e9b3f53ee8b58ba076719642b60e6c6a385bd82f6c0e.css" integrity="sha384-LXHoyz4JmkX4ZfISNs2UVMF6SRiNuuEehaDps/U&#43;6LWLoHZxlkK2DmxqOFvYL2wO"crossorigin="anonymous">
    
    
        
        <script src="/docs/js/katex.min.29c00f3c13ecd528102ceaaf01c03b5dd697260b163f2fc975b60c129d6f157babddb6d399eb4fc8876b0708fcf9ba83.js" integrity="sha384-KcAPPBPs1SgQLOqvAcA7XdaXJgsWPy/JdbYMEp1vFXur3bbTmetPyIdrBwj8&#43;bqD"defer></script>
    <script src="/docs/js/auto-render.min.37bbffecf63ad080846fcb85afc455064d24048a73a0b9475c9ccf86b0ba4f8dcb0aa2047db27ac1bf94af5c6cc4b2e3.js" integrity="sha384-N7v/7PY60ICEb8uFr8RVBk0kBIpzoLlHXJzPhrC6T43LCqIEfbJ6wb&#43;Ur1xsxLLj"defer></script>
    
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.getElementById("content"), {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
    
    </head>
<body>
        <div class="content">
            <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/%E5%9B%BE%E8%AE%BA%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/">
                                
                                【图论】单源最短路问题
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95/">
                                
                                【字符串】kmp算法
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/aes%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/">
                                
                                AES密码算法
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB/">
                                
                                ARP攻击
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/">
                                
                                ARP攻击详解
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/git%E6%8A%A5%E9%94%99%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%8E%86%E7%A8%8B/">
                                
                                Git报错与修改历程
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="current">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/">
                                
                                RSA算法讲解
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/godan/">
                                
                                XSS 漏洞
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/bigintcalc/">
                                
                                大数乘法优化的几点方法
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://whutd.github.io/docs/%E6%BC%AB%E8%B0%88sql-/">
                                
                                漫谈SQL
                            </a>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                    <main class="page-content bg-transparent">
                        
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
            </ul>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>


                            <div class="container-fluid">
                                <div class="layout-spacing">
                                    
                                        <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">RSA算法讲解</span>
                <meta itemprop="position" content='2' />
            </li>
        
    </ul>
</nav></div>
                                    
                                    <div class="row flex-xl-nowrap">
                                        
                                        <div class="docs-toc col-xl-3  visually-hidden  d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="TableOfContents"></nav>
    </toc></div>
                                        
                                        
                                        <div class="docs-toc-mobile  visually-hidden  d-print-none d-xl-none">
                                            <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                                Table of Contents
                                            </button>
<nav id="toc-mobile"></nav></div>
                                        <div class="docs-content col-12  mt-0">
                                            <div class="mb-0 d-flex">
                                                
                                                <h1 class="content-title mb-0">
                                                    RSA算法讲解
                                                    
                                                </h1>
                                            </div>
                                            
                                            <div id="content" class="main-content" >
                                                
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <p><strong>一、生成密钥的基本步骤</strong>
$\textcircled {1}$ 寻找两个质数<code>p</code> <code>q</code>
$\textcircled {2}$ 两个质数相乘计算<code>N</code>
<code>N = p * q</code>
$\textcircled {3}$ 使用欧拉函数计算<code>T</code>
<code>T = (p - 1)*(q - 1)</code>
$\textcircled {4}$ 选择合适的公钥<code>E</code> <strong>(注意：<code>E</code>应该是一个质数，且不是<code>T</code>的因子)</strong>
$\textcircled {5}$ 计算生成私钥<code>D</code> , 其中<code>D</code>应当满足：<code>（D * E）% T = 1</code></p>
<p>经过上述操作，我们将得到<strong>公钥对</strong><code>（N, E）</code>与<strong>私钥对</strong><code>(N, D)</code>,其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下：
$$
明文^E % N = 密文\
密文^D % N = 明文\
$$
接下来我将具体讲解每个步骤的原理。</p>
<hr>
<p><strong>二、寻找质数<code>p</code> <code>q</code></strong></p>
<ol>
<li>随机数生成


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">random_num</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">srand</span>(<span style="color:#a6e22e">time</span>(NULL));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> bai_num <span style="color:#f92672">=</span> (<span style="color:#a6e22e">rand</span>() <span style="color:#f92672">%</span> (<span style="color:#ae81ff">600</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">300</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">300</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//int p = (rand() % (max_t - min_t + 1)) + min_t;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> two_num <span style="color:#f92672">=</span> (<span style="color:#a6e22e">rand</span>() <span style="color:#f92672">%</span> (<span style="color:#ae81ff">99</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rad_num <span style="color:#f92672">=</span> bai_num <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">+</span> two_num;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rad_num;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
这里我们采用C语言的<code>rand()</code>函数，并且以<strong>时间为种子</strong>生成随机数，注意到这里我<strong>生成了两个随机数</strong>，原因是：
为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，<strong>很难保证生成的随机数的均匀分布</strong>（<strong>即每次生成的大随机数很接近</strong>），因此我将五位数的前三位和后两位<strong>分开随机生成</strong>，可以确保生成的随机数在所给区间里的均匀分配</li>
<li>判断生成的随机数是不是质数
这里我们采用<code>Miller Rabin素性检验</code>,主要原理是利用了质数必然满足费马小定理，也即<strong>质数一定满足费马小定理，但是满足费马小定理的可能是伪素数</strong>，但我们可以通过<strong>多次检验</strong>来降低出错概率
参考文献： <a href="https://zhuanlan.zhihu.com/p/349360074" rel="external" target="_blank">Miller Rabin素性检验<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a>
代码如下：


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">miller_rabin_test</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> n, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 处理小数和偶数的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 将 n - 1 表示为 d * 2^r
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> d <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">while</span> ((d <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span> 	d <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> 	r<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 执行 k 次测试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rand</span>() <span style="color:#f92672">%</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> x <span style="color:#f92672">=</span> <span style="color:#a6e22e">mod_pow</span>(a, d, n);
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> x <span style="color:#f92672">==</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span> 		x <span style="color:#f92672">=</span> <span style="color:#a6e22e">mod_pow</span>(x, <span style="color:#ae81ff">2</span>, n);
</span></span><span style="display:flex;"><span> 		<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span> 	}
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">mod_pow</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> exp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> mod) {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> base <span style="color:#f92672">=</span> base <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">while</span> (exp <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">if</span> (exp <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 		result <span style="color:#f92672">=</span> (result <span style="color:#f92672">*</span> base) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span> 	exp <span style="color:#f92672">=</span> exp <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> 	base <span style="color:#f92672">=</span> (base <span style="color:#f92672">*</span> base) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span> }</span></span></code></pre></div>
</li>
</ol>
<p><strong>通过以上办法我们成功找到了两个合适的质数<code>p</code> <code>q</code></strong></p>
<hr>
<p><strong>三、计算N以及T的值</strong>
这里我着重讲解以下<strong>欧拉函数</strong>
==定义==：
对于一个正整数n， n的欧拉函数$\phi(n)$表示小于等于n的与n互质的正整数个数。
==性质1==：
如果n为质数，那么$\phi(n) = n - 1$
==性质2==：
如果p，q都为质数，那么$\phi(p \cdot q) = \phi(p) \times \phi(q) = (p - 1) \times (q - 1)$
==性质3==：
若p为质数，则$\phi(p^k) = p^k - p^{k-1}$</p>
<hr>
<p><strong>四、选择公钥E</strong>
这里的公钥E一般是人为自己选择的，<strong>只需要确保E与T==互质==即可，一般不要太大</strong></p>
<hr>
<p><strong>五、计算私钥</strong>
==引理1==：
辗转相除法（欧几里得算法）：
$$
gcd(a,b) = gcd(b, a%b) = \cdots
$$
其中gcd中第一个参数大于第二个参数
现在我们回到所要解决的问题：
计算生成私钥<code>D</code> , 其中<code>D</code>应当满足：<code>（D * E）% T = 1</code>，其中E和T我们已经在前面得到
将<code>（D * E）% T = 1</code>变形，有：
<code>E(已知)* D = k（未知）T + 1</code>
对于这个问题，我们可以知道的是，对于不同的k，可能会有不同的D与之对应，但我们只需要找到一个最接近0的即可</p>
<p>==引理2==：
拓展欧几里得算法如下
例子：给定正整数$a$, $b$（<strong>互质且默认a&gt;b</strong>）, 求满足$ax+by = 1$的解$x$和$y$(这里会发现和我们上述式子形式基本一致)
那么我们会有：
$$
ax+by=1 = gcd(a, b) = gcd(b, a mod b) = bx&rsquo;+ (amodb)y&rsquo; =bx&rsquo; + (a-b\lfloor\frac{a}{b}\rfloor)y&rsquo;\
整理一下，得到\
ax+by = 1 和ay&rsquo; + b(x&rsquo; - \lfloor\frac{a}{b}\rfloor y&rsquo;) = 1
$$
所以我们认为，
$$
x = y&rsquo;, y = x&rsquo; - \lfloor\frac{a}{b}\rfloor y&rsquo;
$$
这里我们和欧几里得算法一样不断进行下去，最终会得到比较简单的结果，在根据递推关系求解出原问题。</p>
<p>代码如下：</p>


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">calculate</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> max, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> min) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (min <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {  <span style="color:#75715e">// (1, 0) -&gt; (result[0] 系数大值)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		result[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> temp1 <span style="color:#f92672">=</span> result[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> temp2 <span style="color:#f92672">=</span> result[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>		result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> temp2;
</span></span><span style="display:flex;"><span>		result[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp1 <span style="color:#f92672">-</span> (max <span style="color:#f92672">/</span> min) <span style="color:#f92672">*</span> temp2;
</span></span><span style="display:flex;"><span>		count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//printf(&#34;*(%d, %d)*&#34;, result[0], result[1]);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	max <span style="color:#f92672">=</span> arr[count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>	min <span style="color:#f92672">=</span> arr[count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">calculate</span>(max, min);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>我们采用递归的方法计算，把每次计算结果存储在arr中。</p>
<hr>
<p><strong>六、对信息的加密和解密</strong>
这里我主要介绍一个快速算模幂的算法：</p>


    
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">modular_exponentiation</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> exponent, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> modulus) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	base <span style="color:#f92672">=</span> base <span style="color:#f92672">%</span> modulus;  <span style="color:#75715e">// 更新底数为小于模数的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (exponent <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果指数是奇数，乘上底数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (exponent <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>			result <span style="color:#f92672">=</span> (result <span style="color:#f92672">*</span> base) <span style="color:#f92672">%</span> modulus;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 平方底数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		base <span style="color:#f92672">=</span> (base <span style="color:#f92672">*</span> base) <span style="color:#f92672">%</span> modulus;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 整除指数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		exponent <span style="color:#f92672">=</span> exponent <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>用于解决明文和密文之间的转换</p>

    </div>

    

    
                                            </div>
                                            <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap ">
	<div class="col-sm-6 pt-2 doc-next">
		<a href="/docs/git%E6%8A%A5%E9%94%99%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%8E%86%E7%A8%8B/">
			<div class="card h-100 my-1">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0"><i class="material-icons align-middle">navigate_before</i> Git报错与修改历程</p>
					
				</div>
			</div>
		</a>
        </div>
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/docs/godan/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">XSS 漏洞 <i class="material-icons align-middle">navigate_next</i></p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
            </div>
        </div>

        
        
        <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
        
        

        
        




    
    
    






    

    <script src="/docs/js/bootstrap.c7927bdd82eceb076739257add3f4b0e11379da037c07d5c7110daeb6de0e3edcb2de867604550f88815157e4ec4ddb7.js" integrity="sha384-x5J73YLs6wdnOSV63T9LDhE3naA3wH1ccRDa623g4&#43;3LLehnYEVQ&#43;IgVFX5OxN23"defer></script>


    <script type="text/javascript" src="https://whutd.github.io/docs/js/bundle.min.4b07706b1da436c9600e641a8cf51af20b3e497ead85e0d0af7552a0314e8e317dc63bb69d12c072092518621478900d.js" integrity="sha384-Swdwax2kNslgDmQajPUa8gs&#43;SX6theDQr3VSoDFOjjF9xju2nRLAcgklGGIUeJAN" crossorigin="anonymous" defer></script>

        

        
        <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/docs\/%E5%9B%BE%E8%AE%BA%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98\/",
                title: "【图论】单源最短路问题",
                description: "0x01 问题描述 link给定 n 个点，m 条有向边的带非负权图，请你计算从起点 s 出发，到每个点的距离。数据保证你能从 s 出发到任意点。 原链接\" lastmod: “2024-12-12T00:35:\n0x02 前置知识：C语言图的构建 link既然想要解决这个问题，我们首先要明白的是如何在C语言中将一个图来表示出来。这里提供两种方法。当然两种方法的原理是互通的,所以其实理解一种剩下一种也不难看懂。\n1. 链式前向星 link 核心代码1（图的存储方式） int head[N];//head[i]中存储第i个的第一条边的编号\rint cnt=0;//用来计算边的数量\rstruct EDGE {\rint next;\rint to;//next指向该边起点连的下一条边的编号，to是指这条边的终点,当然可以为这个结构体添加更多变量来存储这条边更多的信息，看题目的具体要求\r}edge[M];//此处假定点最多为N个而边最多为M条 好的，那么我们如何向里面来添加边，从而真正的做成一个图呢？\n",
                content: "0x01 问题描述 link给定 n 个点，m 条有向边的带非负权图，请你计算从起点 s 出发，到每个点的距离。数据保证你能从 s 出发到任意点。 原链接\" lastmod: “2024-12-12T00:35:\n0x02 前置知识：C语言图的构建 link既然想要解决这个问题，我们首先要明白的是如何在C语言中将一个图来表示出来。这里提供两种方法。当然两种方法的原理是互通的,所以其实理解一种剩下一种也不难看懂。\n1. 链式前向星 link 核心代码1（图的存储方式） int head[N];//head[i]中存储第i个的第一条边的编号\rint cnt=0;//用来计算边的数量\rstruct EDGE {\rint next;\rint to;//next指向该边起点连的下一条边的编号，to是指这条边的终点,当然可以为这个结构体添加更多变量来存储这条边更多的信息，看题目的具体要求\r}edge[M];//此处假定点最多为N个而边最多为M条 好的，那么我们如何向里面来添加边，从而真正的做成一个图呢？\n核心代码2（建图操作） void addedge(int u,int v){//u是这条边的起点，v是终点\redge[++cnt].to=v;\redge[cnt].next=head[u];\rhead[u]=cnt;\r} 这里实际上是模拟了指针的操作。\n核心代码3（遍历这个图） void dfs(int s){\rfor(int i=head[s];i;i=ed[i].next){\rint v=ed[i].to;\rdfs(v);\r}\r}//这里有一些东西需要注意一下。\r//其一，这里的图是无环的，如果有环的话需要对经过的点做上标记，要不然就会进入死循环。\r//其二，这里的遍历也可以使用队列实现，与dfs(深度优先遍历)相对的，这种方法叫做bfs（广度优先遍历），这里不在赘述。 2. 使用c中的vector来实现 link这种方式比较简单。\n核心代码 #include\r#include\r#include\rusing namespace std;\rstruct Edge {\rint to;\rint cost;\r};\rvector G[10000];//G[i]代表从i出发的边，vector里存的是边\rint n,m;//n为顶点数，m为边数 int temp1;//顶点数，因为G[i][j]中i表示顶点，j表示i顶点邻边储存的数据\r//（编号，最大值为G[i].size() )，所以顶点是一定要单独读入的 int main(void) {\rscanf(\"%d%d\",\u0026n,\u0026m);//结点数，边数,从1开始\rwhile(m--) {\rEdge e;\rscanf(\"%d%d%d\",\u0026temp1,\u0026e.to,\u0026e.cost);\rG[temp1].push_back(e);//一个顶点，将其附带数据（结构体形式）塞进vector }\rfor(int i=1; i\u003c=n; i++) { //遍历从每个节点出发的所有边\rfor(int j=0; j"
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/docs\/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95\/",
                title: "【字符串】kmp算法",
                description: "作用 link用于快速快速查找模式串（子串）pattern在主串（母串）main中出现的位置。\n注意，此处是匹配子串的要求，而子串是连续的\n原理 link前置知识：前缀函数 link对于一个字符串，将它 不包含自身的前后缀（称为真前后缀） 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 最长匹配真前后缀的长度，此过程记为函数$π$\n例如：对于字符串 $s=$ATAATA 含有真前缀为ATAAT ATAA ATA AT A ∅ 含有真后缀为TAATA AATA ATA TA A ∅ 匹配的前后缀有ATA，A，∅，长度分别为$3、1、0$ 则字符串ATAATA的$π$值为$3$\n然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是前缀函数。\n字符串ATAATA的前缀函数数组如下\n下标 $i$ 0 1 2 3 4 5 前缀字符串 A AT ATA ATAA ATAAT ATAATA $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ 即$π[i]$就是子串 $s[0…i]$ 最长匹配真前后缀的长度\nkmp原理 link如果将主串main和模式串pattern以一个特殊字符#链接在一起 并计算这个字符串的前缀函数，如果存在$π[i]$等于pattern的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与pattern完全相同。\n设main=AGCATAATAATTAA，pattern=ATAATA，则合并串s=ATAATA#AGCATAATAATTAA\n合并串 A T A A T A # A G C A T A A T A A T T A A $i$ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ $0$ $1$ $0$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $4$ $5$ $0$ $1$ $1$ 可以看到$π[15]=6$，的确$s[0…i]=$ATAATA#AGCATAATA,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。\n",
                content: "作用 link用于快速快速查找模式串（子串）pattern在主串（母串）main中出现的位置。\n注意，此处是匹配子串的要求，而子串是连续的\n原理 link前置知识：前缀函数 link对于一个字符串，将它 不包含自身的前后缀（称为真前后缀） 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 最长匹配真前后缀的长度，此过程记为函数$π$\n例如：对于字符串 $s=$ATAATA 含有真前缀为ATAAT ATAA ATA AT A ∅ 含有真后缀为TAATA AATA ATA TA A ∅ 匹配的前后缀有ATA，A，∅，长度分别为$3、1、0$ 则字符串ATAATA的$π$值为$3$\n然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是前缀函数。\n字符串ATAATA的前缀函数数组如下\n下标 $i$ 0 1 2 3 4 5 前缀字符串 A AT ATA ATAA ATAAT ATAATA $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ 即$π[i]$就是子串 $s[0…i]$ 最长匹配真前后缀的长度\nkmp原理 link如果将主串main和模式串pattern以一个特殊字符#链接在一起 并计算这个字符串的前缀函数，如果存在$π[i]$等于pattern的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与pattern完全相同。\n设main=AGCATAATAATTAA，pattern=ATAATA，则合并串s=ATAATA#AGCATAATAATTAA\n合并串 A T A A T A # A G C A T A A T A A T T A A $i$ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $π[i]$ $0$ $0$ $1$ $1$ $2$ $3$ $0$ $1$ $0$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $4$ $5$ $0$ $1$ $1$ 可以看到$π[15]=6$，的确$s[0…i]=$ATAATA#AGCATAATA,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。\n用$m$表示pattern的长度，则如果在某一位置 $i$ 有 $pi[i]=m$ 成立，则字符串pattern在字符串main的 $i-(m-1)-(m+1)=i-2m$处出现。\nint pi[N+M]; string s=pattern+'#'+main; int n=main.size(),m=pattern.size(); for(int i=1;i\u003cs.size();i++){ if(pi[i]==m){ printf(\"模式串在主串的%d处出现\\n\",i-m-m); } } $π[i]$的计算 link假设$0$~$π[i-1]$已经求出,记 $len=π[i-1]$，则$s[0…len-1]==s[i-len…i-1]$。\n如果 s[i]==s[len] link则 $s[0…len]==s[i-len…i]$ 所以 $π[i]=len+1$ 如果 s[i]!=s[len] link则$s[0…len]！=s[i-len…i]$\n由于$len$是子串 $s[0…i-1]$ 最长匹配真前后缀的长度，但是可能存在仅次于$len$的第二长匹配真前后缀长度$len2$,使得当$s[i]==s[len2]$时，$s[0…len2]==s[i-len2…i]$。\n所以我们需要比较$s[i]$和$s[len2]$,当$s[i]==s[len2]$时，$π[i]=len2+1$\n当$s[i]!=s[len2]$时，寻找第三长匹配真前后缀长度 $len3$\n$$ \\overbrace{\\underbrace{s_0}{len3}\\underset{\\text{len3}}{s_1}}^{len2}\\overset{\\text{len2}}{s_2}s_3s_4~\\dots~\\overbrace{s{i-2}~\\underbrace{s_{i-1}}_{len3}}^{len2}~s_i $$\n比较$s[i]$和$s[len3]$,当$s[i]==s[len3]$时，$π[i]=len3+1$\n以此类推，每次都寻找下一个长度的匹配真前后缀长度pi_next，一直直到$π$最小即 $len=0$\n用代码写为\nint pi[N+M]; pi[0]=0;//第一个字符不存在真前缀 for(int i=1;i\u003cs.size();i++){ int len=pi[i-1]; while(len \u0026\u0026 s[i]!=s[len]){ len=pi_next; } if(s[i]==s[len])pi[i]=len+1; } $pi$_$next$的计算 link当$s[len]!=s[i]$且$s[len2]==s[i]$时 $∵len==π[i-1]$ $∴s[0…len-1]==s[i-len…i-1]$\n$$ \\overbrace{s_0 ~ s_1 ~ {s_2} ~ s_3}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s_{i-4} ~ s_{i-3} ~ s_{i-2} ~ s_{i-1}}^{len} ~ s_{i} $$\n$∴s[len-len2…len-1]==s[i-len2…i-1]$\n$$ \\overbrace{s_0 ~ s_1 ~ \\underbrace{{s_2} ~ s_3}{len2}}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s{i-4} ~ s_{i-3} ~ \\underbrace{s_{i-2} ~ s_{i-1}}{len2}}^{len} ~ s{i} $$\n$∵len2==π_{next}[i-1]$ $∴s[0…len2-1]==s[i-len2…i-1]$\n$$ \\overbrace{\\underbrace{s_0 ~ s_1}{len2} ~ {s_2} ~ s_3}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s{i-4} ~ s_{i-3} ~ \\underbrace{s_{i-2} ~ s_{i-1}}{len2}}^{len} ~ s{i} $$\n$∴s[0…len2-1]==s[len-len2…len-1]$\n$$ \\overbrace{\\underbrace{s_0 ~ s_1}{len2} ~ \\underbrace{{s_2} ~ s_3}{len2}}^{len} ~ \\overset{\\text{len}}{s_4} ~ \\dots ~ \\overbrace{s_{i-4} ~ s_{i-3} ~ s_{i-2} ~ s_{i-1}}^{len} ~ s_{i} $$\n于是，$s[0…len-1]$中前$len2$个字符与后$len2$个字符相同，这就是这段区间最长的匹配前后缀。\n$len2=π[len-1]$\n显然我们可以得到一个关于$len$的转移方程$len_i=π[len_{i-1}]$\n通过循环代码写为：\nwhile(len \u0026\u0026 s[i]!=s[len]){ len=pi[len-1]; } 代码实现 link最后，我们可以得到kmp算法的简洁代码\nint pi[N]; // pi[i]表示第i个前缀 最长匹配真前后缀 的长度 string s = pattern + '#' + main; int n = main.size(), m = pattern.size(); for(int i = 1; i \u003c s.size(); i++){ int len = pi[i - 1]; // 查找最长匹配的真前后缀 while(len \u0026\u0026 s[i] != s[len]){ len = pi[len - 1]; } if(s[i] == s[len]){ pi[i] = len + 1; // 如果找到完全匹配，输出起始位置 if(pi[i]==m){ printf(\"模式串在主串的%d处出现\\n\",i-m-m); } } } 复杂度分析 link主循环从$i = 1$到$s.size() - 1$遍历整个字符串$s$，其中$s$是由模式串、分隔符和主串组成的。因此，此循环最多执行$s.size()$次。\n在每次迭代中，有一个内部的$while$循环，用来回溯寻找最长匹配真前后缀。虽然看起来像是嵌套循环导致了二次方的时间复杂度，但实际上每个字符被比较的次数是有限制的。具体来说，因为$len$每次都会减少至少$1$，且在整个过程中只能增加$s.size()$次，所以整体来看，内层的$while$循环不会超过外层循环的次数。这意味着构造部分匹配表的过程总共需要$O(n+m)$的时间，其中$n$是字符串$main$的长度，$m$是字符串$pattern$的长度。\n时间复杂度为 $O(n+m)$\n而 $\\pi$ 数组需要开至少$n+m+1的$大小，空间复杂度为 $O(n+m)$\n相关题目 link洛谷P3375 【模版】KMP link题目描述 link给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。\n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n定义一个字符串 $s$ 的 border 为 $s$ 的一个非 $s$ 本身的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。\n对于 $s_2$，你还需要求出对于其每个前缀 $s’$ 的最长 border $t’$ 的长度。\n输入格式 link第一行为一个字符串，即为 $s_1$。\n第二行为一个字符串，即为 $s_2$。\n输出格式 link首先输出若干行，每行一个整数，按从小到大的顺序输出 $s_2$ 在 $s_1$ 中出现的位置。\n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。\n样例输入 #1 link ABABABC\rABA 样例输出 #1 link 1\r3\r0 0 1 分析 link此题为模版题，其中要输出的 border 长度即为 $pi$ 数组\n代码 link #include using namespace std; const int N = 2000000 + 10; int pi[N]; // pi[i]表示第i个前缀 最长匹配真前后缀 的长度 int main(){ string main, pattern; cin \u003e\u003e main \u003e\u003e pattern; // 创建一个新的字符串s，用于存储pattern、分隔符'#'以及main string s = pattern + '#' + main; int n = main.size(), m = pattern.size(); for(int i = 1; i \u003c s.size(); i++){ int len = pi[i - 1]; // 查找最长匹配的真前后缀 while(len \u0026\u0026 s[i] != s[len]){ len = pi[len - 1]; } if(s[i] == s[len]){ pi[i] = len + 1; // 如果找到完全匹配，输出起始位置 if(pi[i] == m){ cout \u003c\u003c (i - m - m + 1) \u003c\u003c endl; } } } // 输出模式字符串部分的pi数组值 for(int i = 0; i \u003c m; i++) printf(\"%d \", pi[i]); return 0; } "
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/docs\/aes%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95\/",
                title: "AES密码算法",
                description: "AES密码算法 link 小声bb：某只学了一学期c语言程序设计、没有计算机基础、数学水平只有一学期的高等数学和线性代数、没有任何密码学基础的大一新生被抛给了一个博客任务，临时抱佛脚学习了这个密码算法。笔者水平有限，如有疏漏望谅解和指正，并希望能帮助到其他的初中级学习者。 注：本篇更注重算法的 应用和实现方法 而非数学基础。\n引言 linkAES是美国政府公开征集的数据加密标准算法，用以取代DES，经过筛选，最终选出 RIJNDAEL 算法作为AES。\n1 加密算法 link1.0 最初步的处理 linkASE算法在对明文加密的时候，并不是把整个明文一股脑的加密成一整段密文，而是把明文 拆分 成一个个独立的明文块，每一个明文块长度128 bit（16个字节，也就是两个十六进制数字）。这些明文经过ASE加密器的复杂处理，生成一个个独立的密文块，这些密文块 拼接 在一起，就是最终的ASE加密结果。\n假如一段明文长度是192 bit，如果按每128 bit一个明文块来拆分的话，第二个明文块只有 64bit，不足128 bit，就需要对明文块进行填充。\n1.1 加密算法构成 linkRIJNDAEL算法采用的是分组密码的一种通用结构：对轮函数实施迭代。 轮函数结构采用的是代替/置换网络结构（SP结构），由非线性层 S盒变换ByteSub、线性混合层 行移位ShiftRow 和 列混合MixColumn、密钥加层 轮密钥加变换AddRoundKey，这三层构成。\n算法构成可以描述为下图情况： 用语言整体叙述一下这个流程：\n我们首先投入主密钥和明文 将主密钥进行 密钥扩展KeyExpansion，扩展成为Nr+1个子密钥 (Nr的取值见1.3.0) 用第1个子密钥对明文做 初始轮密钥加变换AddRoundKey 对该状态依次做S盒变换ByteSub、行移位ShiftRow、列混合MixColumn、用第 i 个子密钥做 轮密钥加变换AddRoundKey。 注意：该步骤重复Nr轮，i 分别在每一轮取2，3,…,Nr+1。其中最后一轮不做列混合MixColumn 得到最终密文 代码：\nvoid AES_Encrypt(unsigned char plaintext[16], unsigned char ciphertext[16], unsigned char roundKeys[11][16], int numberOfRounds) { unsigned char state[16]; // 将明文复制到状态数组 for (int i = 0; i \u003c 16; i++) { state[i] = plaintext[i]; } // 初始轮：加轮密钥 AddRoundKey(state, roundKeys, 0); // 主循环：执行多轮加密操作 for (int round = 1; round \u003c numberOfRounds; round++) { SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state, roundKeys, round); } // 最终轮（不包含MixColumns步骤） SubBytes(state); ShiftRows(state); AddRoundKey(state, roundKeys, numberOfRounds); // 注意：这里的轮数应该是总轮数，但在实际代码中，我们可能使用roundKeys[numberOfRounds-1]，因为轮密钥数组索引是从0开始的 // 将加密后的状态复制到密文字数组 for (int i = 0; i \u003c 16; i++) { ciphertext[i] = state[i]; } } 下面来详细介绍一下每个步骤的操作\n",
                content: "AES密码算法 link 小声bb：某只学了一学期c语言程序设计、没有计算机基础、数学水平只有一学期的高等数学和线性代数、没有任何密码学基础的大一新生被抛给了一个博客任务，临时抱佛脚学习了这个密码算法。笔者水平有限，如有疏漏望谅解和指正，并希望能帮助到其他的初中级学习者。 注：本篇更注重算法的 应用和实现方法 而非数学基础。\n引言 linkAES是美国政府公开征集的数据加密标准算法，用以取代DES，经过筛选，最终选出 RIJNDAEL 算法作为AES。\n1 加密算法 link1.0 最初步的处理 linkASE算法在对明文加密的时候，并不是把整个明文一股脑的加密成一整段密文，而是把明文 拆分 成一个个独立的明文块，每一个明文块长度128 bit（16个字节，也就是两个十六进制数字）。这些明文经过ASE加密器的复杂处理，生成一个个独立的密文块，这些密文块 拼接 在一起，就是最终的ASE加密结果。\n假如一段明文长度是192 bit，如果按每128 bit一个明文块来拆分的话，第二个明文块只有 64bit，不足128 bit，就需要对明文块进行填充。\n1.1 加密算法构成 linkRIJNDAEL算法采用的是分组密码的一种通用结构：对轮函数实施迭代。 轮函数结构采用的是代替/置换网络结构（SP结构），由非线性层 S盒变换ByteSub、线性混合层 行移位ShiftRow 和 列混合MixColumn、密钥加层 轮密钥加变换AddRoundKey，这三层构成。\n算法构成可以描述为下图情况： 用语言整体叙述一下这个流程：\n我们首先投入主密钥和明文 将主密钥进行 密钥扩展KeyExpansion，扩展成为Nr+1个子密钥 (Nr的取值见1.3.0) 用第1个子密钥对明文做 初始轮密钥加变换AddRoundKey 对该状态依次做S盒变换ByteSub、行移位ShiftRow、列混合MixColumn、用第 i 个子密钥做 轮密钥加变换AddRoundKey。 注意：该步骤重复Nr轮，i 分别在每一轮取2，3,…,Nr+1。其中最后一轮不做列混合MixColumn 得到最终密文 代码：\nvoid AES_Encrypt(unsigned char plaintext[16], unsigned char ciphertext[16], unsigned char roundKeys[11][16], int numberOfRounds) { unsigned char state[16]; // 将明文复制到状态数组 for (int i = 0; i \u003c 16; i++) { state[i] = plaintext[i]; } // 初始轮：加轮密钥 AddRoundKey(state, roundKeys, 0); // 主循环：执行多轮加密操作 for (int round = 1; round \u003c numberOfRounds; round++) { SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state, roundKeys, round); } // 最终轮（不包含MixColumns步骤） SubBytes(state); ShiftRows(state); AddRoundKey(state, roundKeys, numberOfRounds); // 注意：这里的轮数应该是总轮数，但在实际代码中，我们可能使用roundKeys[numberOfRounds-1]，因为轮密钥数组索引是从0开始的 // 将加密后的状态复制到密文字数组 for (int i = 0; i \u003c 16; i++) { ciphertext[i] = state[i]; } } 下面来详细介绍一下每个步骤的操作\n1.2 密钥 link1.2.1 主密钥选择 linkAES支持三种长度的密钥：128位、192位、256位。 平时大家说的AES128、AES192、AES256，实际上就是对不同长度密钥的使用。 AES256安全性最高、AES128性能最好，本质在于它们的加密轮数不同。\n1.2.2 密钥扩展KeyExpansion linkRijndael 算法的密钥扩展基于以下几种原理和运算：\n字（Word）的概念： linkRijndael 算法中的密钥扩展以 字（Word） 为基本处理单元，每个字由 4个字节（32位） 组成。 如果密钥长度为 128 位（16 字节），则初始密钥由 4个字 组成；如果密钥长度为 192 位或 256 位，则由 6或8个字 组成。\n轮密钥的生成数量： linkRijndael 算法的加密轮数（Nr）由密钥长度和块大小决定：\n把 状态 表示为二维字节数组(每个元素为一个字节)，它有四行，Nb列。 Nb等于数据块长度除以 32: 数据块长度为128时，Nb=4。数据块长度为192时，Nb=6。数据块长度分别为256时，Nb=8。 因为状态数组有四行，每个元素为一个字节，所以状态的每列便为一个四字节的字。 类似地，密钥 也可表示为二维字节数组(每个元素为一个字节)，它有四行，Nk列。Nk等于密钥块长度除32。\nNr Nb=4 Nb=6 Nb=8 Nk=4 10 12 14 Nk=6 12 12 14 Nk=8 14 14 14 例如：如果是128位的密钥和128位的数据块，则轮函数迭代10次 每轮加密需要一个轮密钥，外加一个初始轮密钥，因此需要生成 (Nr + 1) × 4 个字 的密钥。\n注明：本文代码均以128位密码、128位数据块的情况为例。\n核心操作： link1.字移位与字节替换（RotWord 和 SubWord）：将前一个字进行循环左移操作并替换字节。 2.轮常量异或（Rcon XOR）：将固定的轮常量与结果字异或。 3.从前面的字生成新字：通过前一轮密钥的若干字进行异或运算生成新的字。\n密钥扩展的步骤 link假设密钥长度为 128 位（最常见情况），以下是具体的密钥扩展步骤：\n初始化密钥 输入密钥被分成 4个字：W[0], W[1], W[2], W[3]。 这些字作为密钥扩展的起点。 轮密钥生成 每生成一个新字，需要用到前一个字（W[i - 1]）和前一个轮的字（W[i - Nk]，其中 Nk 是密钥的字数）。 如果当前字的索引 i 是 Nk 的倍数（例如 128 位密钥的情况下，Nk = 4），则执行以下特殊步骤： 字循环移位（RotWord）： 将 W[i - 1] 的 4 个字节循环左移一个字节。 例如，[a0, a1, a2, a3] 变为 [a1, a2, a3, a0]。 字节替换（SubWord）： 对经过循环移位的字，使用 AES 的 S盒（Substitution Box） 逐字节替换。 轮常量异或（Rcon XOR）： 将替换后的结果与轮常量（Rcon）异或。 轮常量（Rcon） 是一个固定表，依赖当前轮数：Rcon[i] = [2^(i-1), 0x00, 0x00, 0x00] 例如，第一轮的 Rcon 为 [0x01, 0x00, 0x00, 0x00]。 重复上述过程 按照上述规则，重复生成字，直到生成了所有的轮密钥。 代码：\n// 密钥扩展函数 void KeyExpansion(unsigned char * K, unsigned char k[11][16]) { for (int i = 0; i \u003c 16; i++) k[0][i] = K[i]; // 扩展密钥的前4个字为种子密钥，共16字 for (int i = 1; i \u003c 11; i++) { k[i][0] = k[i-1][0] ^ S[k[i-1][13]] ^ Rcon[i-1]; k[i][1] = k[i-1][1] ^ S[k[i-1][14]]; k[i][2] = k[i-1][2] ^ S[k[i-1][15]]; k[i][3] = k[i-1][3] ^ S[k[i-1][12]]; k[i][4] = k[i-1][4] ^ k[i][0]; k[i][5] = k[i-1][5] ^ k[i][1]; k[i][6] = k[i-1][6] ^ k[i][2]; k[i][7] = k[i-1][7] ^ k[i][3]; k[i][8] = k[i-1][8] ^ k[i][4]; k[i][9] = k[i-1][9] ^ k[i][5]; k[i][10] = k[i-1][10] ^ k[i][6]; k[i][11] = k[i-1][11] ^ k[i][7]; k[i][12] = k[i-1][12] ^ k[i][8]; k[i][13] = k[i-1][13] ^ k[i][9]; k[i][14] = k[i-1][14] ^ k[i][10]; k[i][15] = k[i-1][15] ^ k[i][11]; // 第i轮轮密钥的第 } } 1.3 轮函数 link加密轮数在1.2.2的“轮密钥的生成数量”中已经说明。加密轮数（Nr）由密钥长度和块大小决定。\n初始轮密钥加变换 和 轮函数中的轮密钥加变换 完全相同，放到1.3.4统一叙述\n1.3.1 S盒变换ByteSub link变换方法如下 如果你觉得这个步骤很费解又复杂，没关系 好消息：你不用理解和掌握S盒变换，你可以直接查表 将S盒变换前的状态写为两个十六进制数字，高位低位对应表头就可以查出S盒变换后的状态了 代码：\n// 字节替换函数（使用 S-box） void SubBytes(uint8_t* state) { for (int i = 0; i \u003c 16; i++) { state[i] = S[state[i]]; } } //以下一个表 unsigned char S[256] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 }; 1.3.2 行移位ShiftRow linkShiftRow 变换是对状态的行进行循环移位变换。在ShiftRow 变换中，状态的第0行不移位，第1行循环左移C1字节，第2行循环左移C2字节，第3行循环左移C3宁节移位值C1，C2和C3与Nb有关,如图。\nNb C1 C2 C3 4 1 2 3 6 1 2 3 8 1 3 4 例如，对于128位密钥128位数据块\n代码：\nvoid ShiftRows(unsigned char* a) { unsigned char b[16]; b[0] = a[0]; b[4] = a[4]; b[8] = a[8]; b[12] = a[12]; b[1] = a[5]; b[5] = a[9]; b[9] = a[13]; b[13] = a[1]; b[2] = a[10]; b[6] = a[14]; b[10] = a[2]; b[14] = a[6]; b[3] = a[15]; b[7] = a[3]; b[11] = a[7]; b[15] = a[11]; for(int i = 0; i \u003c 16; i++) { a[i] = b[i]; } } 1.3.3 列混合MixColumn linkMixColumn变换是对状态的列进行混合变换。在MixColum变换中，把状态中的每一列看做GF($2^8$)上的多项式，并与一个固定多项式c(x)相乘然后模多项式 $x^4+1$，其中c(x)为: $$ c(x)=‘03’x^3 + ‘01’x^2 + ‘01’x + ‘02’ $$ 因为 c(x) 与 $x^4+1$ 是互素的，从而保证 c(x) 存在逆多项式 d(x) （确保了可逆性），使 c(x)d(x) = 1 mod $x^4+1$。只有逆多项式d(x)存在，才能正确进行解密。\n如果你又觉得这个步骤很费解又复杂，没关系 因为又有一个好消息：你不用理解和掌握列混合，你可以直接查表\n具体原因的数学原理如下： 如果存储空间足够，可以造一个大表。如果存储空间不够，可以造小表。造大表，计算时查表的次数少，计算速度快，但占用存储空间较大。造小表，计算时查表的次数多，计算速度慢，但占用存储空间较小。\n代码：\nvoid MixColumns(unsigned char* a) { unsigned char b[16]; b[0] = (S2[a[0]] ^ S3[a[1]] ^ a[2] ^ a[3]); b[1] = (S2[a[1]] ^ S3[a[2]] ^ a[3] ^ a[0]); b[2] = (S2[a[2]] ^ S3[a[3]] ^ a[0] ^ a[1]); b[3] = (S2[a[3]] ^ S3[a[0]] ^ a[1] ^ a[2]); b[4] = (S2[a[4]] ^ S3[a[5]] ^ a[6] ^ a[7]); b[5] = (S2[a[5]] ^ S3[a[6]] ^ a[7] ^ a[4]); b[6] = (S2[a[6]] ^ S3[a[7]] ^ a[4] ^ a[5]); b[7] = (S2[a[7]] ^ S3[a[4]] ^ a[5] ^ a[6]); b[8] = (S2[a[8]] ^ S3[a[9]] ^ a[10] ^ a[11]); b[9] = (S2[a[9]] ^ S3[a[10]] ^ a[11] ^ a[8]); b[10] = (S2[a[10]] ^ S3[a[11]] ^ a[8] ^ a[9]); b[11] = (S2[a[11]] ^ S3[a[8]] ^ a[9] ^ a[10]); b[12] = (S2[a[12]] ^ S3[a[13]] ^ a[14] ^ a[15]); b[13] = (S2[a[13]] ^ S3[a[14]] ^ a[15] ^ a[12]); b[14] = (S2[a[14]] ^ S3[a[15]] ^ a[12] ^ a[13]); b[15] = (S2[a[15]] ^ S3[a[12]] ^ a[13] ^ a[14]); for(int i = 0; i \u003c16; i++) a[i] = b[i]; } //以下两个表 unsigned char S2[256] = {0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e, 0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e, 0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e, 0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e, 0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e, 0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe, 0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde, 0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe, 0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05, 0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25, 0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45, 0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65, 0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85, 0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5, 0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5, 0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5 }; unsigned char S3[256] = { 0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11, 0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21, 0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71, 0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41, 0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1, 0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1, 0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1, 0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81, 0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a, 0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba, 0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea, 0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda, 0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a, 0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a, 0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a, 0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a }; 1.3.4 轮密钥加变换AddRoundKey link对当前状态进行异或上轮密钥（子密钥）操作，即：状态 = 前状态$\\oplus$轮密钥（子密钥） 代码：\nvoid AddRoundKey(unsigned char* state, unsigned char roundKeys[11][16], int round) { for(int i = 0; i \u003c 16; i++) state[i] ^= roundKeys[round][i]; } 2 解密算法 link2.1 解密算法构成 linkASE算法是一种 对称 的加密算法，即加密和解密用同一个密钥。解密算法其实就相当于将加密算法做 逆操作。 代码：\nvoid AES_Decrypt(unsigned char ciphertext[16], unsigned char result[16], unsigned char roundKeys[11][16], int numberOfRounds) { unsigned char Rstate[16]; // 将明文复制到状态数组 for (int i = 0; i \u003c 16; i++) { Rstate[i] = ciphertext[i]; } //unsigned char RroundKeys[11][16]; //InverseKeyExpansion(roundKeys, RroundKeys); // 初始轮：加轮密钥 AddRoundKey(Rstate, roundKeys, 10); InverseShiftRows(Rstate); InverseSubBytes(Rstate); // 主循环：执行多轮加密操作 for (int round = numberOfRounds - 1; round \u003e 0; round--) { AddRoundKey(Rstate, roundKeys, round); InverseMixColumns(Rstate); InverseShiftRows(Rstate); InverseSubBytes(Rstate); } AddRoundKey(Rstate, roundKeys, 0); // 注意：这里的轮数应该是总轮数，但在实际代码中，我们可能使用roundKeys[numberOfRounds-1]，因为轮密钥数组索引是从0开始的 // 将加密后的状态复制到密文字数组 for (int i = 0; i \u003c 16; i++) { result[i] = Rstate[i]; } } 2.2 逆轮函数 link2.2.1 逆S盒变换InverseByteSub link依旧是查表实现 代码：\nvoid InverseSubBytes(uint8_t* state) { for (int i = 0; i \u003c 16; i++) { state[i] = IS[state[i]]; } } //以下一个表 unsigned char IS[256] = { 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D }; 2.2.2 逆行移位InverseShiftRow link在加密时是循环左移，所以解密就是 循环右移 相应的位数 代码：\nvoid InverseShiftRows(unsigned char* a) { unsigned char b[16]; b[0] = a[0]; b[4] = a[4]; b[8] = a[8]; b[12] = a[12]; b[1] = a[13]; b[5] = a[1]; b[9] = a[5]; b[13] = a[9]; b[2] = a[10]; b[6] = a[14]; b[10] = a[2]; b[14] = a[6]; b[3] = a[7]; b[7] = a[11]; b[11] = a[15]; b[15] = a[3]; for(int i = 0; i \u003c 16; i++) { a[i] = b[i]; } } 2.2.3 逆列混合InverseMixColumn link依旧是查表实现 代码：\nvoid InverseMixColumns(unsigned char* a) { unsigned char b[16]; b[0] = SE[a[0]] ^ SB[a[1]] ^ SD[a[2]] ^ s9[a[3]]; b[1] = SE[a[1]] ^ SB[a[2]] ^ SD[a[3]] ^ s9[a[0]]; b[2] = SE[a[2]] ^ SB[a[3]] ^ SD[a[0]] ^ s9[a[1]]; b[3] = SE[a[3]] ^ SB[a[0]] ^ SD[a[1]] ^ s9[a[2]]; b[4] = SE[a[4]] ^ SB[a[5]] ^ SD[a[6]] ^ s9[a[7]]; b[5] = SE[a[5]] ^ SB[a[6]] ^ SD[a[7]] ^ s9[a[4]]; b[6] = SE[a[6]] ^ SB[a[7]] ^ SD[a[4]] ^ s9[a[5]]; b[7] = SE[a[7]] ^ SB[a[4]] ^ SD[a[5]] ^ s9[a[6]]; b[8] = SE[a[8]] ^ SB[a[9]] ^ SD[a[10]] ^ s9[a[11]]; b[9] = SE[a[9]] ^ SB[a[10]] ^ SD[a[11]] ^ s9[a[8]]; b[10] = SE[a[10]] ^ SB[a[11]] ^ SD[a[8]] ^ s9[a[9]]; b[11] = SE[a[11]] ^ SB[a[8]] ^ SD[a[9]] ^ s9[a[10]]; b[12] = SE[a[12]] ^ SB[a[13]] ^ SD[a[14]] ^ s9[a[15]]; b[13] = SE[a[13]] ^ SB[a[14]] ^ SD[a[15]] ^ s9[a[12]]; b[14] = SE[a[14]] ^ SB[a[15]] ^ SD[a[12]] ^ s9[a[13]]; b[15] = SE[a[15]] ^ SB[a[12]] ^ SD[a[13]] ^ s9[a[14]]; for(int i = 0; i \u003c 16; i++) a[i] = b[i]; } //以下四个表 unsigned char s9[256] = { 0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77, 0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7, 0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c, 0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc, 0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01, 0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91, 0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a, 0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa, 0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b, 0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b, 0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0, 0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30, 0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed, 0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d, 0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6, 0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46 }; unsigned char SB[256] = { 0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69, 0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9, 0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12, 0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2, 0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f, 0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f, 0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4, 0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54, 0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e, 0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e, 0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5, 0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55, 0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68, 0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8, 0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13, 0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3 }; unsigned char SD[256] = { 0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b, 0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b, 0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0, 0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20, 0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26, 0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6, 0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d, 0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d, 0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91, 0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41, 0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a, 0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa, 0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc, 0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c, 0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47, 0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97 }; unsigned char SE[256] = { 0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a, 0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba, 0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81, 0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61, 0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7, 0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17, 0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c, 0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc, 0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b, 0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb, 0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0, 0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20, 0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6, 0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56, 0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d, 0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d }; 2.2.4 逆轮密钥加变换InverseAddRoundKey link不难发现二进制的 a $\\oplus$ b = c，则有 c $\\oplus$ b = a 所以只需要再做一次对状态进行轮密钥（子密钥）的异或操作就可以了 即逆轮密钥加变换InverseAddRoundKey和轮密钥加变换AddRoundKey其实是一样的。不再重复写一遍代码了。\n3 AES应用场景 link3.1 数据加密传输 linkAES广泛用于保护数据在网络中的安全传输，确保数据在传输过程中即使被拦截也无法被解读。\nHTTPS/TLS协议：在HTTPS（基于TLS协议）中，AES是用于加密数据流的主要算法之一，保护用户的敏感信息（如密码、银行交易等）免受中间人攻击。 VPN（虚拟私人网络）：VPN使用AES加密用户的网络流量，确保数据在不安全的网络（如公共Wi-Fi）中的安全性。 无线网络安全（WPA/WPA2/WPA3）：无线局域网的安全协议（如Wi-Fi的WPA2和WPA3）使用AES来加密通信，防止无线信号被窃听和篡改。 3.2 文件和存储加密 linkAES常用于保护静态数据，例如文件、数据库或磁盘上的存储数据。\n全盘加密： 操作系统（如Windows BitLocker、macOS FileVault）使用AES对硬盘进行加密，保护设备丢失或被盗后的数据安全。 云存储加密： 云存储服务（如Google Drive、Dropbox等）通常使用AES加密用户上传的文件，防止未经授权的访问。 数据库加密： 数据库管理系统（如MySQL、PostgreSQL）使用AES加密敏感数据字段（如用户密码和个人信息）。 3.3 通信应用 linkAES在即时通信和其他通信服务中确保消息的机密性和完整性。\n消息加密： 即时通信应用（如WhatsApp、Signal）使用AES加密消息内容，确保只有通信双方能够解密消息。 电子邮件加密： 邮件加密工具（如PGP/GPG）可能结合AES对邮件内容进行加密。 "
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/docs\/arp%E6%94%BB%E5%87%BB\/",
                title: "ARP攻击",
                description: "0x00 OSI模型 link在开放系统互连（OSI）参考模型中，网络工作被划分为七个层次。各层之间并不直接进行交互，而是仅通过层接口（Layer Interface）实现彼此间的通信。\nIP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。\n0x01 ARP协议 link地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。\n0x02 ARP攻击 link1.表现 link一般情况下，受到ARP攻击的计算机会出现两种现象：\n不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。\n计算机不能正常上网，出现网络中断的症状。\n除此之外，用户可能还会遭遇信息泄露的情况。\n2.原理 linkARP协议是TCP/IP协议组的一个协议，这个协议是建立在局域网上主机相互信任的基础上的，局域网中的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性并直接将其记入本机ARP缓存。ARP缓存表采用的是机械制原理，如果表中的某一列长时间不使用，就会被删除。也就是说ARP的缓存表是可以被更改的。表中的IP地址和MAC地址也是随时可以修改，这样在局域网中很容易被ARP欺骗。\n在网络通信过程中，当客户机向外部网络发送数据包时，首先会借助ARP协议来获取网关的MAC地址。之后，客户机会将 IP 数据包封装在以太网帧中，并发送给该网关，由网关负责后续的转发工作。\n然而，网络环境并非绝对安全。当有恶意人员接入网络后，会对网络中的 ARP 流量进行监听。由于 ARP 地址解析请求采用广播的方式发送，网络中的所有参与者都能够接收到该请求，黑客自然也不例外。\n以 PC 解析网关 192.168.50.1 的 MAC 地址这一过程为例。当黑客嗅探到 ARP 请求后，可能会实施恶意行为。黑客会伪装成网关，伪造 ARP 应答信息来欺骗 PC。PC 在接收到 ARP 应答后，会将应答结果存储在 ARP 缓存中。由于 ARP 协议缺乏有效的校验机制，PC 很容易受到黑客的欺骗。需要注意的是，网关也会向 PC 发送真实的 ARP 应答。在此情况下，PC 会依据系统协议栈的规则来采信应答信息，而系统协议栈通常以最新接收到的应答作为有效信息。\n黑客在嗅探到 ARP 请求后，会持续发送虚假应答，总有一个虚假应答能够覆盖网关发送的真实应答，从而进入 PC 的 ARP 缓存表。这种攻击方式被称为 ARP 泛洪（ARP Flooding）。\n",
                content: "0x00 OSI模型 link在开放系统互连（OSI）参考模型中，网络工作被划分为七个层次。各层之间并不直接进行交互，而是仅通过层接口（Layer Interface）实现彼此间的通信。\nIP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。\n0x01 ARP协议 link地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。\n0x02 ARP攻击 link1.表现 link一般情况下，受到ARP攻击的计算机会出现两种现象：\n不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。\n计算机不能正常上网，出现网络中断的症状。\n除此之外，用户可能还会遭遇信息泄露的情况。\n2.原理 linkARP协议是TCP/IP协议组的一个协议，这个协议是建立在局域网上主机相互信任的基础上的，局域网中的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性并直接将其记入本机ARP缓存。ARP缓存表采用的是机械制原理，如果表中的某一列长时间不使用，就会被删除。也就是说ARP的缓存表是可以被更改的。表中的IP地址和MAC地址也是随时可以修改，这样在局域网中很容易被ARP欺骗。\n在网络通信过程中，当客户机向外部网络发送数据包时，首先会借助ARP协议来获取网关的MAC地址。之后，客户机会将 IP 数据包封装在以太网帧中，并发送给该网关，由网关负责后续的转发工作。\n然而，网络环境并非绝对安全。当有恶意人员接入网络后，会对网络中的 ARP 流量进行监听。由于 ARP 地址解析请求采用广播的方式发送，网络中的所有参与者都能够接收到该请求，黑客自然也不例外。\n以 PC 解析网关 192.168.50.1 的 MAC 地址这一过程为例。当黑客嗅探到 ARP 请求后，可能会实施恶意行为。黑客会伪装成网关，伪造 ARP 应答信息来欺骗 PC。PC 在接收到 ARP 应答后，会将应答结果存储在 ARP 缓存中。由于 ARP 协议缺乏有效的校验机制，PC 很容易受到黑客的欺骗。需要注意的是，网关也会向 PC 发送真实的 ARP 应答。在此情况下，PC 会依据系统协议栈的规则来采信应答信息，而系统协议栈通常以最新接收到的应答作为有效信息。\n黑客在嗅探到 ARP 请求后，会持续发送虚假应答，总有一个虚假应答能够覆盖网关发送的真实应答，从而进入 PC 的 ARP 缓存表。这种攻击方式被称为 ARP 泛洪（ARP Flooding）。\n一旦受害者的 ARP 缓存表被黑客篡改，其网络通信将完全处于黑客的控制之下。以 PC 为例，原本需要通过网关转发至外部网络的 IP 数据包，会被黑客劫持，导致 PC 无法访问外部网络，出现网络中断的情况。但这种攻击方式不仅难以获取实际利益，还容易被发现。\n为了保持攻击的隐蔽性，黑客通常会充当中间人，将劫持的数据包继续转发至真正的网关。要实现这一目的，黑客需要同时欺骗网关和 PC。\nPC 被黑客欺骗后，会将外出数据包发送给黑客，而黑客则会将这些数据包转发至网关，进而使其进入互联网，形成类似上述绿色路径的通信过程。与此同时，网关也会被黑客欺骗，误认为黑客就是 PC，从而将发往 PC 的数据包发送给黑客，黑客再将数据包转发给 PC，形成类似上述红色路径的通信过程。\n当 PC 的网络流量经过黑客的控制范围时，黑客便可以实施各种恶意行为。黑客可以对 PC 的网络速率进行限制，严重影响其网络使用体验。更为严重的是，黑客还可以对 PC 的数据包进行分析，从中窃取敏感信息，如账号和密码等。特别是当 PC 使用非加密的超文本传输协议（HTTP）与外部进行通信时，其传输的数据将完全暴露在黑客面前。因此，在不安全的网络环境中，必须使用超文本传输安全协议（HTTPS）来保障数据的安全性。\n3.防御对策 link在路由和终端上同时进行 IP 地址和 MAC 地址的绑定，相当于人工管理 ARP 缓存，自行维护 IP 地址和 MAC 地址的对应关系。既然将 ARP 协议弃之不用，黑客就无法发起攻击了。这个方案虽然可以奏效，但维护非常繁琐。换个网卡或 IP 地址，都需要重新修改配置。当流动电脑临时接入时，也要即时进行绑定，费时费力。\n使用 PPPoE 协议对网络流量进行二次封装，为每个用户都分配账号密码，上网时必须通过认证。这样 ARP 报文在一个认证的通道中传输，也就不会遭受攻击了。 但 PPPoE 也不是完美的，由于二次封装的存在，传输效率会打些折扣。更严重的是，PPPoE 方式下局域网内无法互访。如果局域网内需要部署文件服务器、打印机，就有麻烦了。\nDHCP snooping，网络设备可借由DHCP保留网络上各电脑的MAC地址，在伪造的ARP数据包发出时即可侦测到。此方式已在一些厂牌的网络设备产品所支持。\n有一些软件可监听网络上的ARP回应，若侦测出有不正常变动时可发送电子邮件通知管理者。例如UNIX平台的Arpwatch以及Windows上的XArp v2[2]或一些网络设备的Dynamic ARP inspection功能。\n其实最关键的一点在于，坚持使用 HTTPS 这样的加密协议。这样就算遭遇 ARP 劫持，信息也不会被窃取。在陌生的网络环境中，应该尽量不用 HTTP 这样的明文协议。\n"
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/docs\/arp%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3\/",
                title: "ARP攻击详解",
                description: "0x00 什么是ARP协议 linkARP（Address Resolution Protocol，地址解析协议）是TCP/IP协议栈中网络层的重要协议之一，主要用于将IP地址解析为对应的MAC地址，以便设备在局域网内正常通信。\n在局域网中，通信通常依赖于MAC地址，ARP的基本工作流程如下：\n设备A需要发送数据给设备B，它知道设备B的IP地址，但是不知道设备B的MAC地址； 设备A发送一个ARP请求，询问哪个设备对应IP地址是设备B； 设备B收到ARP请求后，回复设备A一个包含自己MAC地址的ARP响应； 设备A将这个IP和MAC的对应关系存储在自己的ARP缓存中，以后可以直接使用。 举个栗子：我想去腾讯总部（IP地址）,但不知道具体位置（MAC地址）,这时我就可以通过导航软件(ARP)找到腾讯大厦。 示意图如下：\nsequenceDiagram\rA-\u003e\u003eNetwork: 广播ARP请求\rNetwork-\u003e\u003eB: 转发请求\rB-\u003e\u003eA: 返回目标MAC地址\rA-\u003e\u003eCache: 存储IP-MAC映射 0x01 什么是ARP攻击 linkARP攻击利用了ARP协议本身的一个漏洞：ARP协议没有任何验证机制，攻击者可以伪造ARP请求或响应，欺骗网络中的设备，使其将错误的MAC地址绑定到一个合法的IP地址。这样攻击者就可以拦截、修改甚至伪造网络中的数据。 常见的ARP攻击方式有以下几种：\nARP欺骗：伪造ARP响应，欺骗目标设备，将攻击者的MAC地址绑定到合法设备的IP地址； 中间人攻击（MITM）：通过ARP欺骗将自己伪装成通信双方，实现对数据包的监听和篡改； ARP泛洪攻击：大量发送伪造的ARP响应，填满目标设备的ARP缓存，导致网络异常。 示意图如下: sequenceDiagram\rAttacker-\u003e\u003eA: 伪造ARP响应（假冒网关）\rA-\u003e\u003eCache: 更新IP-MAC映射（错误）\rA-\u003e\u003eAttacker: 发送数据（实际应发往网关） 0x02 ARP攻击的危害: linkARP攻击的危害包括但不限于：\n流量劫持：攻击者可以截获目标设备的网络流量，窃取敏感信息； 网络瘫痪：通过ARP泛洪攻击使设备无法正常通信； 数据篡改：攻击者可在通信过程中篡改数据包内容，进行恶意操作。 0x03 如何防范ARP攻击 link尽管ARP协议本身缺乏安全性，但可以通过以下方式降低ARP攻击的风险：\n静态ARP表：手动将设备的IP地址和MAC地址绑定起来，避免被伪造的ARP响应修改。这种方法适用于重要的设备（如服务器、网关等）。 Windows中设置静态ARP表： # 查看当前的ARP缓存\rarp -a\r# 添加静态ARP条目，手动绑定IP和MAC地址\rarp -s 192.168.1.1 00-11-22-33-44-55 启用ARP绑定：部分路由器支持将IP地址与MAC地址绑定。 使用VLAN：通过划分虚拟局域网，隔离不同设备之间的通信。 网络监控工具：利用工具如Wireshark或arpwatch监控ARP异常。 安全协议：使用HTTPS、SSH等加密协议，确保即使数据被拦截，也不会泄露敏感信息,防止敏感信息泄露。 0x04 实例分析:ARP攻击的模拟与防护 link下面我们通过一个简单的例子来演示如何进行ARP攻击，并介绍如何防护。 1. 环境准备 假设我们有三台设备：\n设备A（IP地址：192.168.1.100）是受害者； 设备B（IP地址：192.168.1.1）是网关； 设备C（IP地址：192.168.1.200）是攻击者。 攻击工具：arpspoof（一般在Kali Linux中使用，但Windows下可以通过Cygwin或WSL模拟Linux环境）。 2. ARP攻击步骤\n",
                content: "0x00 什么是ARP协议 linkARP（Address Resolution Protocol，地址解析协议）是TCP/IP协议栈中网络层的重要协议之一，主要用于将IP地址解析为对应的MAC地址，以便设备在局域网内正常通信。\n在局域网中，通信通常依赖于MAC地址，ARP的基本工作流程如下：\n设备A需要发送数据给设备B，它知道设备B的IP地址，但是不知道设备B的MAC地址； 设备A发送一个ARP请求，询问哪个设备对应IP地址是设备B； 设备B收到ARP请求后，回复设备A一个包含自己MAC地址的ARP响应； 设备A将这个IP和MAC的对应关系存储在自己的ARP缓存中，以后可以直接使用。 举个栗子：我想去腾讯总部（IP地址）,但不知道具体位置（MAC地址）,这时我就可以通过导航软件(ARP)找到腾讯大厦。 示意图如下：\nsequenceDiagram\rA-\u003e\u003eNetwork: 广播ARP请求\rNetwork-\u003e\u003eB: 转发请求\rB-\u003e\u003eA: 返回目标MAC地址\rA-\u003e\u003eCache: 存储IP-MAC映射 0x01 什么是ARP攻击 linkARP攻击利用了ARP协议本身的一个漏洞：ARP协议没有任何验证机制，攻击者可以伪造ARP请求或响应，欺骗网络中的设备，使其将错误的MAC地址绑定到一个合法的IP地址。这样攻击者就可以拦截、修改甚至伪造网络中的数据。 常见的ARP攻击方式有以下几种：\nARP欺骗：伪造ARP响应，欺骗目标设备，将攻击者的MAC地址绑定到合法设备的IP地址； 中间人攻击（MITM）：通过ARP欺骗将自己伪装成通信双方，实现对数据包的监听和篡改； ARP泛洪攻击：大量发送伪造的ARP响应，填满目标设备的ARP缓存，导致网络异常。 示意图如下: sequenceDiagram\rAttacker-\u003e\u003eA: 伪造ARP响应（假冒网关）\rA-\u003e\u003eCache: 更新IP-MAC映射（错误）\rA-\u003e\u003eAttacker: 发送数据（实际应发往网关） 0x02 ARP攻击的危害: linkARP攻击的危害包括但不限于：\n流量劫持：攻击者可以截获目标设备的网络流量，窃取敏感信息； 网络瘫痪：通过ARP泛洪攻击使设备无法正常通信； 数据篡改：攻击者可在通信过程中篡改数据包内容，进行恶意操作。 0x03 如何防范ARP攻击 link尽管ARP协议本身缺乏安全性，但可以通过以下方式降低ARP攻击的风险：\n静态ARP表：手动将设备的IP地址和MAC地址绑定起来，避免被伪造的ARP响应修改。这种方法适用于重要的设备（如服务器、网关等）。 Windows中设置静态ARP表： # 查看当前的ARP缓存\rarp -a\r# 添加静态ARP条目，手动绑定IP和MAC地址\rarp -s 192.168.1.1 00-11-22-33-44-55 启用ARP绑定：部分路由器支持将IP地址与MAC地址绑定。 使用VLAN：通过划分虚拟局域网，隔离不同设备之间的通信。 网络监控工具：利用工具如Wireshark或arpwatch监控ARP异常。 安全协议：使用HTTPS、SSH等加密协议，确保即使数据被拦截，也不会泄露敏感信息,防止敏感信息泄露。 0x04 实例分析:ARP攻击的模拟与防护 link下面我们通过一个简单的例子来演示如何进行ARP攻击，并介绍如何防护。 1. 环境准备 假设我们有三台设备：\n设备A（IP地址：192.168.1.100）是受害者； 设备B（IP地址：192.168.1.1）是网关； 设备C（IP地址：192.168.1.200）是攻击者。 攻击工具：arpspoof（一般在Kali Linux中使用，但Windows下可以通过Cygwin或WSL模拟Linux环境）。 2. ARP攻击步骤\n在攻击者C上启动ARP欺骗（Windows上使用Cygwin或WSL模拟Linux环境）： # 伪装成网关，欺骗设备A\rarpspoof -i eth0 -t 192.168.1.100 192.168.1.1 这样，设备A会误以为攻击者C是网关，发送数据给攻击者C。 2. 同时，在攻击者C上伪装成设备A，欺骗设备B（网关）：\n# 伪装成设备A，欺骗网关\rarpspoof -i eth0 -t 192.168.1.1 192.168.1.100 这样，设备B（网关）也会误以为攻击者C是设备A。 3. 通过这种方式，攻击者C可以拦截、监听甚至篡改设备A与设备B之间的通信。\n3. 如何防护 在设备A上，我们可以设置静态ARP条目，确保即使有ARP攻击，设备A也不会受到影响。 在Windows系统中，通过以下命令设置静态ARP表：\n# 添加静态ARP条目，防止ARP欺骗\rarp -s 192.168.1.1 00-11-22-33-44-55 这条命令将设备A的ARP缓存锁定为：设备A的网关（192.168.1.1）对应的MAC地址是 00-11-22-33-44-55。这样，即使攻击者伪造ARP响应，设备A也不会更新其ARP缓存。\n0x05 总结 linkARP攻击是网络中的一种经典攻击方式，它通过伪造ARP响应，可以让攻击者劫持流量、窃取信息、甚至篡改数据。为了防止ARP攻击，管理员可以通过设置静态ARP表、使用VLAN隔离、启用ARP绑定功能等方法来提高网络的安全性。\n附：ARP编程示例 link ARP请求示例代码 #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include uint8_t src_mac[ETH_ALEN] = {0x08,0x00,0x27,0x06,0x38,0xba};\ruint8_t nexthop_mac[ETH_ALEN] = {0x08,0x00,0x27,0xc1,0xdf,0xea};\r#define LOCAL_IP \"192.168.1.18\"\r#define PEER_IP \"192.168.1.19\"\r#define MAX_BUF_SIZE (2048)\r#define IP_ADDR_LEN (4)\rstruct _arphdr {\r__be16 ar_hrd;\r__be16 ar_pro;\runsigned char ar_hln;\runsigned char ar_pln;\r__be16 ar_op;\runsigned char ar_sha[ETH_ALEN];\runsigned char ar_sip[4];\runsigned char ar_tha[ETH_ALEN];\runsigned char ar_tip[4];\r};\ruint32_t create_pack(char *buf) {\rstruct ethhdr *eh = (struct ethhdr *)buf;\rmemcpy(eh-\u003eh_dest, nexthop_mac, ETH_ALEN);\rmemcpy(eh-\u003eh_source, src_mac, ETH_ALEN);\reh-\u003eh_proto = htons(ETH_P_ARP);\rstruct _arphdr *ah = (struct _arphdr *)(buf + ETH_HLEN);\rah-\u003ear_hrd = htons(ARPHRD_ETHER);\rah-\u003ear_pro = htons(ETH_P_IP);\rah-\u003ear_hln = ETH_ALEN;\rah-\u003ear_pln = IP_ADDR_LEN;\rah-\u003ear_op = htons(ARPOP_REQUEST);\rmemcpy(ah-\u003ear_sha, src_mac, ETH_ALEN);\ruint32_t src_ip = inet_addr(LOCAL_IP);\rmemcpy(ah-\u003ear_sip, \u0026src_ip, IP_ADDR_LEN);\rmemcpy(ah-\u003ear_tha, nexthop_mac, ETH_ALEN);\ruint32_t peer_ip = inet_addr(PEER_IP);\rmemcpy(ah-\u003ear_tip, \u0026peer_ip, IP_ADDR_LEN);\rreturn ETH_HLEN + sizeof(struct _arphdr);\r}\rint main(int argc , char *argv[]) {\rint ret;\rint sockfd;\rchar send_buf[MAX_BUF_SIZE] = {0};\rstruct sockaddr_ll local;\rstruct sockaddr_ll peer;\rsockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ARP));\rif (sockfd == -1) {\rperror(\"socket error\");\rreturn -1;\r}\rbzero(\u0026peer, sizeof(struct sockaddr_ll));\rpeer.sll_family = PF_PACKET;\rpeer.sll_protocol = htons(ETH_P_ARP);\rpeer.sll_ifindex = 2;\rpeer.sll_hatype = ARPHRD_ETHER;\rpeer.sll_pkttype = PACKET_OTHERHOST;\rpeer.sll_halen = ETH_ALEN;\rmemcpy(peer.sll_addr, nexthop_mac, ETH_ALEN);\ruint32_t slen = create_pack(send_buf);\rwhile(1) {\rret = sendto(sockfd, send_buf, slen, 0, (struct sockaddr *)\u0026peer, sizeof(peer));\rif (ret \u003c= 0) {\rprintf(\"sendto ret:%d, errno:%d(%s)\\n\", ret, errno, strerror(errno));\rbreak;\r}\rsleep(1);\r}\rclose(sockfd);\rreturn 0;\r} ARP响应示例代码 #include #include #include #include #include #include #include #include #include #include #include #include #include #include uint8_t src_mac[ETH_ALEN] = {0x08,0x00,0x27,0xc1,0xdf,0xea};\ruint8_t nexthop_mac[ETH_ALEN] = {0x08,0x00,0x27,0x06,0x38,0xba};\r#define LOCAL_IP \"192.168.1.19\"\r#define PEER_IP \"192.168.1.18\"\r#define IP_ADDR_LEN (4)\r#define MAX_BUF_SIZE (2048)\rstruct _arphdr {\r__be16 ar_hrd;\r__be16 ar_pro;\runsigned char ar_hln;\runsigned char ar_pln;\r__be16 ar_op;\runsigned char ar_sha[ETH_ALEN];\runsigned char ar_sip[4];\runsigned char ar_tha[ETH_ALEN];\runsigned char ar_tip[4];\r};\rvoid print_arp(char *msg, const char *buf) {\rstruct _arphdr *ah = (struct _arphdr *)(buf + ETH_HLEN);\rprintf(\"%s\\n\"\r\"硬件类型：%u\\n\"\r\"协议类型：%u\\n\"\r\"硬件地址长度：%u\\n\"\r\"协议地址长度：%u\\n\"\r\"操作码：%u\\n\"\r\"发送方硬件地址：%02hx:%02hx:%02hx:%02hx:%02hx:%02hx\\n\"\r\"发送方协议地址：%02hx.%02hx.%02hx.%02hx\\n\"\r\"接收方硬件地址：%02hx:%02hx:%02hx:%02hx:%02hx:%02hx\\n\"\r\"接收方协议地址：%02hx.%02hx.%02hx.%02hx\\n\",\rmsg,\rntohs(ah-\u003ear_hrd),\rntohs(ah-\u003ear_pro),\rah-\u003ear_hln,\rah-\u003ear_pln,\rntohs(ah-\u003ear_op),\rah-\u003ear_sha[0], ah-\u003ear_sha[1], ah-\u003ear_sha[2], ah-\u003ear_sha[3], ah-\u003ear_sha[4], ah-\u003ear_sha[5],\rah-\u003ear_sip[0], ah-\u003ear_sip[1], ah-\u003ear_sip[2], ah-\u003ear_sip[3],\rah-\u003ear_tha[0], ah-\u003ear_tha[1], ah-\u003ear_tha[2], ah-\u003ear_tha[3], ah-\u003ear_tha[4], ah-\u003ear_tha[5],\rah-\u003ear_tip[0], ah-\u003ear_tip[1], ah-\u003ear_tip[2], ah-\u003ear_tip[3]);\r}\rint parse_pack(char *msg, char *buf) {\rprint_arp(msg, buf);\rreturn 0;\r}\ruint32_t create_pack(char *sbuf, char *rbuf) {\rstruct ethhdr *eh = (struct ethhdr *)sbuf;\rmemcpy(eh-\u003eh_dest, nexthop_mac, ETH_ALEN);\rmemcpy(eh-\u003eh_source, src_mac, ETH_ALEN);\reh-\u003eh_proto = htons(ETH_P_ARP);\rstruct _arphdr *rah = (struct _arphdr *)(rbuf + ETH_HLEN);\rstruct _arphdr *ah = (struct _arphdr *)(sbuf + ETH_HLEN);\rah-\u003ear_hrd = htons(ARPHRD_ETHER);\rah-\u003ear_pro = htons(ETH_P_IP);\rah-\u003ear_hln = ETH_ALEN;\rah-\u003ear_pln = IP_ADDR_LEN;\rah-\u003ear_op = htons(ARPOP_REPLY);\rmemcpy(ah-\u003ear_sha, src_mac, ETH_ALEN);\ruint32_t src_ip = inet_addr(LOCAL_IP);\rmemcpy(ah-\u003ear_sip, \u0026src_ip, IP_ADDR_LEN);\rmemcpy(ah-\u003ear_tha, rah-\u003ear_sha, ETH_ALEN);\rmemcpy(ah-\u003ear_tip, rah-\u003ear_sip, IP_ADDR_LEN);\rreturn ETH_HLEN + sizeof(struct _arphdr);\r}\rbool isvalid(const char *buf) {\rstruct ethhdr *eh = (struct ethhdr *)buf;\rif (ntohs(eh-\u003eh_proto) == ETH_P_ARP) return true;\rreturn false;\r}\rint main(int argc , char *argv[]) {\rint ret;\rint sockfd;\rchar send_buf[MAX_BUF_SIZE] = {0};\rchar recv_buf[MAX_BUF_SIZE] = {0};\rstruct sockaddr_ll peer;\rsocklen_t peerlen = 0;\rsockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ARP));\rif (sockfd == -1) {\rperror(\"socket error\");\rreturn -1;\r}\rbzero(\u0026peer, sizeof(struct sockaddr_ll));\rpeer.sll_family = PF_PACKET;\rpeer.sll_protocol = htons(ETH_P_ARP);\rpeer.sll_ifindex = 2;\rpeer.sll_hatype = ARPHRD_ETHER;\rpeer.sll_pkttype = PACKET_OTHERHOST;\rpeer.sll_halen = ETH_ALEN;\rmemcpy(peer.sll_addr, nexthop_mac, ETH_ALEN);\rwhile(1) {\rmemset(recv_buf, 0, MAX_BUF_SIZE);\rret = recvfrom(sockfd, recv_buf, MAX_BUF_SIZE, 0, NULL, NULL);\rif (ret \u003c= 0) {\rprintf(\"recvfrom ret:%d error\\n\", ret);\rbreak;\r} else {\rbool bret = isvalid(recv_buf);\rprintf(\"ret:%d, bret:%d\\n\", ret, bret);\rif (bret == false) {\rcontinue;\r}\rparse_pack(\"recv buf\", recv_buf);\rmemset(send_buf, 0, MAX_BUF_SIZE);\rint slen = create_pack(send_buf, recv_buf);\rslen += 18;\rprintf(\"sendbuf len:%d\\n\", slen);\rret = sendto(sockfd, send_buf, slen, 0, (struct sockaddr *)\u0026peer, sizeof(peer));\rif (ret \u003c= 0) {\rprintf(\"sendto ret:%d error:%d(%s)\\n\", ret, errno, strerror(errno));\rbreak;\r}\r}\r}\rclose(sockfd);\rreturn 0;\r} "
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/docs\/git%E6%8A%A5%E9%94%99%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%8E%86%E7%A8%8B\/",
                title: "Git报错与修改历程",
                description: "1.报错情景 link某日打开电脑，想要git pull一下云端代码，发现如下报错\n![image-20250204103956684](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204103956684.png)\n显示连接超时，尝试了git clone 与git push好像都用不了了，但是还能正常访问Github\n使用ssh -T git@github.com来查看链接情况\n![image-20250204104404309](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204104404309.png)\n这种情况就是22端口被占用\n2.解决方式 link（1）.使用HTTPS连接 linkgit config --local -e打开本地git 配置文件\n![image-20250204110813289](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204110813289.png)\n把这段使用git@github.com的SSH链接改为\n![image-20250204110849275](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204110849275.png)\nHTTPS的链接\n（2）.尝试切换端口 link访问电脑路径C:\\Users\\%你的用户名%\\.ssh![image-20250204105222170](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204105222170.png)\n如果没有config文件，就打开vscode创建一个，粘贴如下配置进去\nHost github.com\rUser git\rHostname ssh.github.com\rPreferredAuthentications publickey\rIdentityFile ~/.ssh/id_rsa\rPort 443 即使用443端口访问github，保存\n再使用ssh -T git@github.com来尝试访问github\n![image-20250204105526091](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204105526091.png)\n提示重新建立连接，输入yes\n此时可以正常git clone,再git pull，发现仍然无法成功\n（3）.重新修改ssh密钥 link注意到这里![image-20250204111656269](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111656269.png)\n经过查询是修改端口后ssh密钥不匹配，于是重新生成对应的密钥,输入指令\nssh-keygen -t rsa -C “your_email.com”![image-20250204111807116](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111807116.png)\n![image-20250204111836436](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111836436.png)\n",
                content: "1.报错情景 link某日打开电脑，想要git pull一下云端代码，发现如下报错\n![image-20250204103956684](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204103956684.png)\n显示连接超时，尝试了git clone 与git push好像都用不了了，但是还能正常访问Github\n使用ssh -T git@github.com来查看链接情况\n![image-20250204104404309](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204104404309.png)\n这种情况就是22端口被占用\n2.解决方式 link（1）.使用HTTPS连接 linkgit config --local -e打开本地git 配置文件\n![image-20250204110813289](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204110813289.png)\n把这段使用git@github.com的SSH链接改为\n![image-20250204110849275](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204110849275.png)\nHTTPS的链接\n（2）.尝试切换端口 link访问电脑路径C:\\Users\\%你的用户名%\\.ssh![image-20250204105222170](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204105222170.png)\n如果没有config文件，就打开vscode创建一个，粘贴如下配置进去\nHost github.com\rUser git\rHostname ssh.github.com\rPreferredAuthentications publickey\rIdentityFile ~/.ssh/id_rsa\rPort 443 即使用443端口访问github，保存\n再使用ssh -T git@github.com来尝试访问github\n![image-20250204105526091](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204105526091.png)\n提示重新建立连接，输入yes\n此时可以正常git clone,再git pull，发现仍然无法成功\n（3）.重新修改ssh密钥 link注意到这里![image-20250204111656269](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111656269.png)\n经过查询是修改端口后ssh密钥不匹配，于是重新生成对应的密钥,输入指令\nssh-keygen -t rsa -C “your_email.com”![image-20250204111807116](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111807116.png)\n![image-20250204111836436](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111836436.png)\n回车，输入y，覆写老密钥，之后一路回车就可以\n![image-20250204111940976](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204111940976.png)\n生成成功，将其导入github，打开settings,![image-20250204112033746](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204112033746.png)\n选择New SSH key\n本地访问C:\\Users\\gao ancheng.ssh，![image-20250204112350752](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204112350752.png)\n用vscode打开选中文件，复制其内容，粘贴到github上，输入密码，如下\n![image-20250204112456409](C:\\Users\\gao ancheng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250204112456409.png)\n再尝试git pull 与git push 可以正常使用\n"
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/docs\/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0\/",
                title: "RSA算法讲解",
                description: "一、生成密钥的基本步骤 $\\textcircled {1}$ 寻找两个质数p q $\\textcircled {2}$ 两个质数相乘计算N N = p * q $\\textcircled {3}$ 使用欧拉函数计算T T = (p - 1)*(q - 1) $\\textcircled {4}$ 选择合适的公钥E (注意：E应该是一个质数，且不是T的因子) $\\textcircled {5}$ 计算生成私钥D , 其中D应当满足：（D * E）% T = 1\n经过上述操作，我们将得到公钥对（N, E）与私钥对(N, D),其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下： $$ 明文^E % N = 密文\\ 密文^D % N = 明文\\ $$ 接下来我将具体讲解每个步骤的原理。\n二、寻找质数p q\n随机数生成 int random_num() { srand(time(NULL)); int bai_num = (rand() % (600 - 300 + 1)) + 300; //int p = (rand() % (max_t - min_t + 1)) + min_t; int two_num = (rand() % (99 - 10 + 1)) + 10; int rad_num = bai_num * 100 + two_num; return rad_num; } 这里我们采用C语言的rand()函数，并且以时间为种子生成随机数，注意到这里我生成了两个随机数，原因是： 为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，很难保证生成的随机数的均匀分布（即每次生成的大随机数很接近），因此我将五位数的前三位和后两位分开随机生成，可以确保生成的随机数在所给区间里的均匀分配 判断生成的随机数是不是质数 这里我们采用Miller Rabin素性检验,主要原理是利用了质数必然满足费马小定理，也即质数一定满足费马小定理，但是满足费马小定理的可能是伪素数，但我们可以通过多次检验来降低出错概率 参考文献： Miller Rabin素性检验 代码如下： int miller_rabin_test(unsigned long long n, int k) { // 处理小数和偶数的情况 if (n \u003c= 1 || (n \u003e 2 \u0026\u0026 n % 2 == 0)) return 0; if (n \u003c= 3) return 1; // 将 n - 1 表示为 d * 2^r unsigned long long d = n - 1; int r = 0; while ((d \u0026 1) == 0) { d \u003e\u003e= 1; r++; } // 执行 k 次测试 for (int i = 0; i \u003c k; i++) { unsigned long long a = 2 + rand() % (n - 4); unsigned long long x = mod_pow(a, d, n); if (x == 1 || x == n - 1) continue; int j; for (j = 0; j \u003c r - 1; j++) { x = mod_pow(x, 2, n); if (x == n - 1) break; } if (j == r - 1) return 0; } return 1; } unsigned long long mod_pow(unsigned long long base, unsigned long long exp, unsigned long long mod) { unsigned long long result = 1; base = base % mod; while (exp \u003e 0) { if (exp % 2 == 1) result = (result * base) % mod; exp = exp \u003e\u003e 1; base = (base * base) % mod; } return result; } 通过以上办法我们成功找到了两个合适的质数p q\n",
                content: "一、生成密钥的基本步骤 $\\textcircled {1}$ 寻找两个质数p q $\\textcircled {2}$ 两个质数相乘计算N N = p * q $\\textcircled {3}$ 使用欧拉函数计算T T = (p - 1)*(q - 1) $\\textcircled {4}$ 选择合适的公钥E (注意：E应该是一个质数，且不是T的因子) $\\textcircled {5}$ 计算生成私钥D , 其中D应当满足：（D * E）% T = 1\n经过上述操作，我们将得到公钥对（N, E）与私钥对(N, D),其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下： $$ 明文^E % N = 密文\\ 密文^D % N = 明文\\ $$ 接下来我将具体讲解每个步骤的原理。\n二、寻找质数p q\n随机数生成 int random_num() { srand(time(NULL)); int bai_num = (rand() % (600 - 300 + 1)) + 300; //int p = (rand() % (max_t - min_t + 1)) + min_t; int two_num = (rand() % (99 - 10 + 1)) + 10; int rad_num = bai_num * 100 + two_num; return rad_num; } 这里我们采用C语言的rand()函数，并且以时间为种子生成随机数，注意到这里我生成了两个随机数，原因是： 为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，很难保证生成的随机数的均匀分布（即每次生成的大随机数很接近），因此我将五位数的前三位和后两位分开随机生成，可以确保生成的随机数在所给区间里的均匀分配 判断生成的随机数是不是质数 这里我们采用Miller Rabin素性检验,主要原理是利用了质数必然满足费马小定理，也即质数一定满足费马小定理，但是满足费马小定理的可能是伪素数，但我们可以通过多次检验来降低出错概率 参考文献： Miller Rabin素性检验 代码如下： int miller_rabin_test(unsigned long long n, int k) { // 处理小数和偶数的情况 if (n \u003c= 1 || (n \u003e 2 \u0026\u0026 n % 2 == 0)) return 0; if (n \u003c= 3) return 1; // 将 n - 1 表示为 d * 2^r unsigned long long d = n - 1; int r = 0; while ((d \u0026 1) == 0) { d \u003e\u003e= 1; r++; } // 执行 k 次测试 for (int i = 0; i \u003c k; i++) { unsigned long long a = 2 + rand() % (n - 4); unsigned long long x = mod_pow(a, d, n); if (x == 1 || x == n - 1) continue; int j; for (j = 0; j \u003c r - 1; j++) { x = mod_pow(x, 2, n); if (x == n - 1) break; } if (j == r - 1) return 0; } return 1; } unsigned long long mod_pow(unsigned long long base, unsigned long long exp, unsigned long long mod) { unsigned long long result = 1; base = base % mod; while (exp \u003e 0) { if (exp % 2 == 1) result = (result * base) % mod; exp = exp \u003e\u003e 1; base = (base * base) % mod; } return result; } 通过以上办法我们成功找到了两个合适的质数p q\n三、计算N以及T的值 这里我着重讲解以下欧拉函数 ==定义==： 对于一个正整数n， n的欧拉函数$\\phi(n)$表示小于等于n的与n互质的正整数个数。 ==性质1==： 如果n为质数，那么$\\phi(n) = n - 1$ ==性质2==： 如果p，q都为质数，那么$\\phi(p \\cdot q) = \\phi(p) \\times \\phi(q) = (p - 1) \\times (q - 1)$ ==性质3==： 若p为质数，则$\\phi(p^k) = p^k - p^{k-1}$\n四、选择公钥E 这里的公钥E一般是人为自己选择的，只需要确保E与T==互质==即可，一般不要太大\n五、计算私钥 ==引理1==： 辗转相除法（欧几里得算法）： $$ gcd(a,b) = gcd(b, a%b) = \\cdots $$ 其中gcd中第一个参数大于第二个参数 现在我们回到所要解决的问题： 计算生成私钥D , 其中D应当满足：（D * E）% T = 1，其中E和T我们已经在前面得到 将（D * E）% T = 1变形，有： E(已知)* D = k（未知）T + 1 对于这个问题，我们可以知道的是，对于不同的k，可能会有不同的D与之对应，但我们只需要找到一个最接近0的即可\n==引理2==： 拓展欧几里得算法如下 例子：给定正整数$a$, $b$（互质且默认a\u003eb）, 求满足$ax+by = 1$的解$x$和$y$(这里会发现和我们上述式子形式基本一致) 那么我们会有： $$ ax+by=1 = gcd(a, b) = gcd(b, a mod b) = bx’+ (amodb)y’ =bx’ + (a-b\\lfloor\\frac{a}{b}\\rfloor)y’\\ 整理一下，得到\\ ax+by = 1 和ay’ + b(x’ - \\lfloor\\frac{a}{b}\\rfloor y’) = 1 $$ 所以我们认为， $$ x = y’, y = x’ - \\lfloor\\frac{a}{b}\\rfloor y’ $$ 这里我们和欧几里得算法一样不断进行下去，最终会得到比较简单的结果，在根据递推关系求解出原问题。\n代码如下：\nvoid calculate(unsigned long long max, unsigned long long min) { if (min == 0) { // (1, 0) -\u003e (result[0] 系数大值) result[1] = 0; result[0] = 1; count--; } else { unsigned long long temp1 = result[0]; unsigned long long temp2 = result[1]; result[0] = temp2; result[1] = temp1 - (max / min) * temp2; count--; } //printf(\"*(%d, %d)*\", result[0], result[1]); if (count == 0) { return; } max = arr[count - 1][0]; min = arr[count - 1][1]; calculate(max, min); } 我们采用递归的方法计算，把每次计算结果存储在arr中。\n六、对信息的加密和解密 这里我主要介绍一个快速算模幂的算法：\nunsigned long long modular_exponentiation(unsigned long long base, unsigned long long exponent, unsigned long long modulus) { unsigned long long result = 1; base = base % modulus; // 更新底数为小于模数的值 while (exponent \u003e 0) { // 如果指数是奇数，乘上底数 if (exponent % 2 == 1) { result = (result * base) % modulus; } // 平方底数 base = (base * base) % modulus; // 整除指数 exponent = exponent / 2; } return result; } 用于解决明文和密文之间的转换\n"
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/docs\/godan\/",
                title: "XSS 漏洞",
                description: "1. 漏洞分析：XSS 漏洞的成因及攻击方式 linkXSS 漏洞的成因 linkXSS（Cross-Site Scripting）漏洞通常发生在 Web 应用程序未对用户输入进行充分的过滤或转义时。攻击者通过将恶意 JavaScript 代码嵌入到 Web 页面中，利用页面没有正确处理用户输入来执行恶意脚本，最终达到窃取用户信息、劫持会话、篡改页面内容等目的。\nXSS 漏洞的主要类型 link 反射型 XSS（Reflected XSS）\n攻击者将恶意脚本嵌入到 URL 或表单字段中，当用户访问该 URL 时，恶意脚本会立即在页面中反射执行。 示例：http://example.com/search?q= 存储型 XSS（Stored XSS）\n攻击者将恶意脚本存储在服务器端（如论坛评论区、用户帖子等），当其他用户访问存储的内容时，恶意脚本被执行。 示例：攻击者在评论区提交 ，其他用户查看该评论时脚本执行。 DOM 型 XSS（DOM-based XSS）\n攻击者通过操作网页上的 DOM 元素来触发脚本执行，而不是依赖服务器的响应。 示例：通过修改 window.location 或 document.location 注入恶意代码。 攻击方式 linkXSS 攻击的目标通常是：\n窃取 Cookies：攻击者通过脚本获取用户的 cookie 信息。 窃取会话：攻击者窃取会话标识符（如 Token），从而劫持用户会话。 篡改页面内容：修改页面 DOM，诱导用户点击恶意链接或输入信息。 劫持用户输入：通过恶意脚本记录用户的键盘输入或篡改表单数据。 2. 攻防技术介绍 link攻击手段 link Payload 编写技巧\n脚本注入：常见的脚本 payload 如 或嵌套多层 HTML 元素，如 。 编码绕过：利用 URL 编码、十六进制编码、Base64 编码等方式绕过过滤机制。 DOM 操控：利用 document.write()、innerHTML 等方法注入恶意脚本。 免杀技术\n",
                content: "1. 漏洞分析：XSS 漏洞的成因及攻击方式 linkXSS 漏洞的成因 linkXSS（Cross-Site Scripting）漏洞通常发生在 Web 应用程序未对用户输入进行充分的过滤或转义时。攻击者通过将恶意 JavaScript 代码嵌入到 Web 页面中，利用页面没有正确处理用户输入来执行恶意脚本，最终达到窃取用户信息、劫持会话、篡改页面内容等目的。\nXSS 漏洞的主要类型 link 反射型 XSS（Reflected XSS）\n攻击者将恶意脚本嵌入到 URL 或表单字段中，当用户访问该 URL 时，恶意脚本会立即在页面中反射执行。 示例：http://example.com/search?q= 存储型 XSS（Stored XSS）\n攻击者将恶意脚本存储在服务器端（如论坛评论区、用户帖子等），当其他用户访问存储的内容时，恶意脚本被执行。 示例：攻击者在评论区提交 ，其他用户查看该评论时脚本执行。 DOM 型 XSS（DOM-based XSS）\n攻击者通过操作网页上的 DOM 元素来触发脚本执行，而不是依赖服务器的响应。 示例：通过修改 window.location 或 document.location 注入恶意代码。 攻击方式 linkXSS 攻击的目标通常是：\n窃取 Cookies：攻击者通过脚本获取用户的 cookie 信息。 窃取会话：攻击者窃取会话标识符（如 Token），从而劫持用户会话。 篡改页面内容：修改页面 DOM，诱导用户点击恶意链接或输入信息。 劫持用户输入：通过恶意脚本记录用户的键盘输入或篡改表单数据。 2. 攻防技术介绍 link攻击手段 link Payload 编写技巧\n脚本注入：常见的脚本 payload 如 或嵌套多层 HTML 元素，如 。 编码绕过：利用 URL 编码、十六进制编码、Base64 编码等方式绕过过滤机制。 DOM 操控：利用 document.write()、innerHTML 等方法注入恶意脚本。 免杀技术\n变种 Payload：通过字符替换、混淆、编码等技术绕过过滤器。 事件属性绕过：通过 onload、onerror、onclick 等事件属性注入脚本，如 。 DOM-based 绕过：通过注入脚本，使其通过 DOM 操作执行。 防御策略 link 输入验证与过滤\n严格对用户输入进行验证，禁止直接注入 发送恶意链接 将该链接发送给目标用户，诱导其点击。\n执行脚本 当用户点击该链接时，攻击者嵌入的脚本在用户的浏览器中执行，弹出警告框 alert(‘XSS’)。\n关键技术 URL 编码绕过：如果服务器对 \u003c 和 \u003e 进行了过滤，可以通过 URL 编码绕过。例如，\u003c 变成 %3C，\u003e 变成 %3E。 事件注入绕过：如果 "
            }
        );
    index.add(
            {
                id:  8 ,
                href: "\/docs\/bigintcalc\/",
                title: "大数乘法优化的几点方法",
                description: " 悲剧地发现看不懂前面的推文后立志要写出只要是上过课的都能懂的文章。请懂的同学通过目录去了解自己有兴趣的内容，或者快速划过这篇推文。\n空间优化 link 压位 link 在获取大数字符串后需要以转换为整形存储，然而，如果数组里只存了1个数字未免有点浪费，所以我们可以进行压位操作，多存几个数字。以10进制存储的大数乘法运算一般压4位。 要注意的是，在例如 77x130=10010 的计算中，积在数组中的存储为[1，10]，输出结果就变成了110.为了避免这种结果，我们需要对输出格式进行一些处理： int BigNumber_print(int*c,int top)//c为逆序存放乘积的数组，top为最高位下标 { printf(\"%d\",c[top]);//最高位所在不能补零输出 for(int i=top-1;i\u003e=0;i--) { printf(\"%04d\",c[i]);//将结果右对齐输出，结果补零，效果如：10-\u003e0010 } return 0; } 事实上，为了全bit存储以及后续部分算法的使用，我们可以将大数以2进制存储，这就需要2个将10进制转化为2进制的输入函数与将2进制转化为10进制的输出函数。这里不多做赘述。 时间优化 link Karatsuba算法优化 link 先来做道竖式计算吧 link相信大家都做过这样的乘法列式计算题。 大数乘法的基本方法就是模拟手算乘法，简单，好想，空间复杂度小，时间复杂度为$O(n^2)$。 这个过程可以理解为： ($24\\times10 + 0\\times1) \\times (3\\times10 + 6\\times1 ) = 72\\times100 + (144+0)\\times10+(0+6)\\times1$ 需要计算的乘法有：24x3、24x6、0x3、0x6\n如果把上面的过程抽象为字符形式： ($a \\times x+b$)($c \\times x+d$)=$ac · x^2+ (ad+bc) \\times x+bd$ 那么为了得出结果，我们需要知道ac、ad、bc、bd这4个乘法运算结果。\n关键的地方到了。\n易知：(a-b)(c-d)=ac+bd-(ad+bc)，若用ac+bd-(a-b)(c-d)来表示(ad+bc)的话，只需要计算3个乘法运算结果：(a-b)(c-d)、ac、bd。\nKaratsuba算法的具体步骤 link理解了上面的内容后，下面介绍Karatsuba算法的具体步骤： 假设2个大数x、y的长度分别为p、q; 取$n=min\\lbrace p,q \\rbrace$; 将x、y表示为：$x=a·10^{n/2} + b；y=c·10^{n/2} + d$； 计算$(a-b)(c-d)、ac、bd$； 结果为：$ac·10^n+[ac+bd-(a-b)(c-d)]·10^{n/2}+bd$ Karatsuba算法的程序实现 link该算法可通过递归实现，需要提前写好大数加减算法。\n",
                content: " 悲剧地发现看不懂前面的推文后立志要写出只要是上过课的都能懂的文章。请懂的同学通过目录去了解自己有兴趣的内容，或者快速划过这篇推文。\n空间优化 link 压位 link 在获取大数字符串后需要以转换为整形存储，然而，如果数组里只存了1个数字未免有点浪费，所以我们可以进行压位操作，多存几个数字。以10进制存储的大数乘法运算一般压4位。 要注意的是，在例如 77x130=10010 的计算中，积在数组中的存储为[1，10]，输出结果就变成了110.为了避免这种结果，我们需要对输出格式进行一些处理： int BigNumber_print(int*c,int top)//c为逆序存放乘积的数组，top为最高位下标 { printf(\"%d\",c[top]);//最高位所在不能补零输出 for(int i=top-1;i\u003e=0;i--) { printf(\"%04d\",c[i]);//将结果右对齐输出，结果补零，效果如：10-\u003e0010 } return 0; } 事实上，为了全bit存储以及后续部分算法的使用，我们可以将大数以2进制存储，这就需要2个将10进制转化为2进制的输入函数与将2进制转化为10进制的输出函数。这里不多做赘述。 时间优化 link Karatsuba算法优化 link 先来做道竖式计算吧 link相信大家都做过这样的乘法列式计算题。 大数乘法的基本方法就是模拟手算乘法，简单，好想，空间复杂度小，时间复杂度为$O(n^2)$。 这个过程可以理解为： ($24\\times10 + 0\\times1) \\times (3\\times10 + 6\\times1 ) = 72\\times100 + (144+0)\\times10+(0+6)\\times1$ 需要计算的乘法有：24x3、24x6、0x3、0x6\n如果把上面的过程抽象为字符形式： ($a \\times x+b$)($c \\times x+d$)=$ac · x^2+ (ad+bc) \\times x+bd$ 那么为了得出结果，我们需要知道ac、ad、bc、bd这4个乘法运算结果。\n关键的地方到了。\n易知：(a-b)(c-d)=ac+bd-(ad+bc)，若用ac+bd-(a-b)(c-d)来表示(ad+bc)的话，只需要计算3个乘法运算结果：(a-b)(c-d)、ac、bd。\nKaratsuba算法的具体步骤 link理解了上面的内容后，下面介绍Karatsuba算法的具体步骤： 假设2个大数x、y的长度分别为p、q; 取$n=min\\lbrace p,q \\rbrace$; 将x、y表示为：$x=a·10^{n/2} + b；y=c·10^{n/2} + d$； 计算$(a-b)(c-d)、ac、bd$； 结果为：$ac·10^n+[ac+bd-(a-b)(c-d)]·10^{n/2}+bd$ Karatsuba算法的程序实现 link该算法可通过递归实现，需要提前写好大数加减算法。\n下面给出1个c++代码参考，来源CSDN。据编写者所说，由于没有考虑string类型的一些函数耗时，实际的运行效率是更低的。粘贴过来是因为觉得这个思路清晰，便于学习理解。仅作参考。\n// 简单乘法，一个数和个位数相乘求积； string multiply(const string\u0026 num1, char num2) { if (num2 == '0' || ISZERO(num1)) { return \"0\"; } int len = num1.size(); string product(len, '0'); int carry = 0; for (int i = len - 1; i \u003e= 0; --i) { int ret = CTOI(num1[i]) * CTOI(num2) + carry; product[len-i-1] = ITOC(ret % 10); carry = ret / 10; } if (carry != 0) product.push_back(ITOC(carry)); reverse(product.begin(), product.end()); return product; } // Karatsuba乘法 string karatsuba(const string\u0026 num1, const string\u0026 num2) { // 递归的简单情况 if (ISZERO(num1) || ISZERO(num2)) { return \"0\"; } if (num1.size() == 1 ) { return multiply(num2, num1[0]); } if (num2.size() == 1) { return multiply(num1, num2[0]); } int len1 = num1.size(); int len2 = num2.size(); int half = ((std::max)(len1, len2) + 1) / 2; // 步骤一:计算a, b, c, d string a = (len1 \u003e half) ? num1.substr(0, len1 - half) : \"0\"; string b = (len1 \u003e half) ? num1.substr(len1 - half, half) : num1; string c = (len2 \u003e half) ? num2.substr(0, len2 - half) : \"0\"; string d = (len2 \u003e half) ? num2.substr(len2 - half, half) : num2; // 步骤二：计算a*c、b*d、(a+b)*(c+d)-a*c-b*d string t0 = karatsuba(a,c); string t1 = karatsuba(b,d); string t2 = karatsuba(add(a, b), add(c, d)); string t3 = sub(sub(t2, t1), t0); // 步骤三：计算乘积结果 string nOffset(2 * half, '0'); string nHalfOffset(half, '0'); string product = add(add((t0 + nOffset), (t3 + nHalfOffset)), t1); return product; } 基于快速傅里叶变换FFT的优化 link 来做一道矩阵乘法吧 link假设有1道乘法计算：521 x 123 = ?，显然： $$521 = 5 \\times 10^2 + 2 \\times 10^1 + 1 \\times 10^0$$ $$123 = 1 \\times 10^2 + 2 \\times 10^1 + 3 \\times 10^0$$\n设x=10，就得到了2个多项式： $f(x) = 5 x^2 + 2 x^1 + 1 x^0$ $g(x) = 1 x^2 + 2 x^1 + 3 x^0$ 则：$h(x) = f(x)g(x) = a + bx^1 + c x^2 + d x^3 + e x^4$； 即$521 \\times 123 = abcde$\n$另取x = {1,2,3}$\n$ \\begin{vmatrix} a \u0026 b \u0026 c \u0026 d \u0026 e \\ \\end{vmatrix} \\times $ $ \\begin{vmatrix} 1 \u0026 1 \u0026 1\\\\ 1^1 \u0026 2^1 \u0026 3^1\\\\ 1^2 \u0026 2^2 \u0026 3^2\\\\ 1^3 \u0026 2^3 \u0026 3^3\\\\ 1^4 \u0026 2^4 \u0026 3^4 \\end{vmatrix}= \\begin{vmatrix} h(1) \u0026 h(2) \u0026 h(3) \\ \\end{vmatrix} $\n通过矩阵运算可得abcde结果（利用范德蒙德矩阵的相关性质） 看上去很神奇，但很遗憾，时间复杂度依然是$O(n^2)$，没有优化。\n为了解决这个问题，让我们重温一下复数的知识。\nFFT（快速傅里叶变换） link不知道大家还记不记得高中数学学过的复数的几何表示：$r(cos(t)+i \\times sin(t)$，复数的乘法可表示为模相乘，辐角相加。 若取$r=1，t=\\dfrac{2\\pi}{n}$，设该复数为$x_n$，易知函数$L(k)=x_4^k$（k为非负整数）是个周期函数，最小正周期为n。 当n=4，情况如下。 可以发现 $x_4^0 = 1 = -x_4^2，x_4^1 = i = -x_4^3$。\n同理设$x_8$，易得$x_4^i=x_8^2i,-x_8^i=x_8^{i+4}，x_4^0=-x_8^4$ $$设f(x) = a_0 x^0 +a_1 x^1 + a_2 x^2 + a_3 x^3 + a_4 x^4 + a_5 x^5 + a_6 x^6 + a_7 x^7，(x取 x_8^0 …… x_8^7)$$ $$设p1(x)=a_0 x^0+ a_2 x^1 + a_4 x^2+ a_6 x^3，p2(x)= a_1 x^0+a_3 x^1+a_5 x^2+ a_7 x^3$$ 则$f(x)=p1(x^2)+x·p2(x^2)$，$f(-x)=p1(x^2)-x·p2(x^2)$ （将多项式函数奇偶分离） 所以$f(x_8^i)=p1(x_4^i)+x_4^i·p2(x_4^{i^2})$，$f(x_8^{4+i})=p1(x_4^i)-x_4^i·p2(x_4^{i^2})（i 取0，1，2，3）$ 成功实现用2个4项多项式表达8项多项式。而且，通过该等式，我们可以构造一种递归的算法，将每一个多项式分解为两项，而每一项又只需要$\\dfrac{n}{2}$计算量，不断递归。时间复杂度为$O(nlogn)$\n另：因为多项式是2个2个地分解的，所以一般需要确保多项式项数说2的整次幂。不足的话就补充系数为零的项。\n这种对f(x)进行的变换就叫做FFT。\n程序实现 link 同样来源于CSDN，仅作参考。\n#include #include #include #include using namespace std; const double PI = acos(-1.0); // 递归实现FFT void fft(vector\u003ccomplex\u003cdouble\u003e\u003e\u0026 a, bool inv) { int n = a.size(); if (n == 1) { return; } //分治 vector\u003ccomplex\u003cdouble\u003e\u003e a0(n / 2), a1(n / 2); for (int i = 0, j = 0; i \u003c n; i += 2, j++) { a0[j] = a[i]; a1[j] = a[i + 1]; } fft(a0, inv); fft(a1, inv); //FFT double angle = 2 * PI / n * (inv ? -1 : 1); complex\u003cdouble\u003e w(1), wn(cos(angle), sin(angle)); for (int i = 0; i \u003c n / 2; i++) { a[i] = a0[i] + w * a1[i]; a[i + n / 2] = a0[i] - w * a1[i]; w *= wn; } } // FFT乘法 vector\u003cint\u003e multiply(vector\u003cint\u003e a, vector\u003cint\u003e b) { int n = 1; // 将多项式的项数变为2的整数次幂 while (n \u003c a.size() + b.size()) { n *= 2; } a.resize(n), b.resize(n); vector\u003ccomplex\u003cdouble\u003e\u003e c(n), d(n); for (int i = 0; i \u003c n; i++) { c[i] = complex\u003cdouble\u003e(a[i], 0); d[i] = complex\u003cdouble\u003e(b[i], 0); } // 求原多项式的FFT fft(c, false), fft(d, false); for (int i = 0; i \u003c n; i++) { c[i] *= d[i]; } // 求乘法结果的IFFT fft(c, true); // 将IFFT中与逆矩阵相差的1/n乘进去 vector\u003cint\u003e res(n); for (int i = 0; i \u003c n; i++) { res[i] = (int)(c[i].real() / n + 0.5); } // 处理进位 int carry = 0; for (int i = 0; i\u003c n; i++) { res[i] += carry; carry = res[i] / 10; res[i] %= 10; } // 去高位的0 while (res.size() \u003e 1 \u0026\u0026 res.back() == 0) { res.pop_back(); } return res; } // 将大整数字符串转换为vector vector\u003cint\u003e to_vector(string s) { vector\u003cint\u003e res; for (int i = s.size() - 1; i \u003e= 0; i--) { res.push_back(s[i] - '0'); } return res; } // 将vector转换为大整数字符串 string to_string(vector\u003cint\u003e a) { string res; for (int i = a.size() - 1; i \u003e= 0; i--) { res += to_string(a[i]); } return res; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vector\u003cint\u003e a = to_vector(s1), b = to_vector(s2); vector\u003cint\u003e c = multiply(a, b); cout \u003c\u003c to_string(c) \u003c\u003c endl; return 0; } "
            }
        );
    index.add(
            {
                id:  9 ,
                href: "\/docs\/%E6%BC%AB%E8%B0%88sql-\/",
                title: "漫谈SQL",
                description: "0x00 SQL是什么？有什么用？ link要谈谈SQL的定性，那我们就必需同时提到另一个概念”数据库“；当今时代数据爆炸，面对巨额的数据，我们创造了数据库这个在线的结构来处理，管理这些数据。而SQL就是一种结构化的数据库操作语言，它使得我们能够高效，准确的获取，修改，操作数据库中我们需要的数据。\n0x01：SQL基本处理与对应语法 link从上一个部分，我们可以把SQL分成以下几个部分\n1.DDL(Data Definition Language)数据定义语言，用来定义数据库对象(库 表 列…)\n2.DML(Data Manipulation Language)数据操作语言，用来操作数据库中的数据\n3.DCL(Data Control Language)数据控制语言，定义数据权限与安全问题\n4.DQL（Data Query Language）数据查询语言，查询数据\n我们一个一个来讲讲基本语法\n以下语法句子中关键字均采取大写处理\n1.DDL link库操作 link 创建数据库：CREATE DATABASE NAME；e.gCREATE DATABASE whustd，创建一个名为 whustd的数据库。如果这个数据已经存在，那么会报错。但是 CREATE DATABASE IF NOT EXISTS whustd，在名为 whustd 的数据库不存在时创建该库，这样可以避免报错。\n删除数据库：DROP DATABASE [IF EXISTS] NAME；e.g DROP DATABASE whustd，删除名为 WHUSTD 的数据库。如果这个数据库不存在，那么会报错。同理 DROP DATABASE IF EXISTS WHUSTD，就算 WHUSTD不存在，也不会的报错。\n修改数据库编码：ALTER DATABASE whustd CHARACTER SET utf8 修改数据库 WHUSTD 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都 不能使用中间的“-”，即 UTF-8 要书写为 UTF8。 修改编码一般是处理非英文内容的编译防止出现乱码。\n",
                content: "0x00 SQL是什么？有什么用？ link要谈谈SQL的定性，那我们就必需同时提到另一个概念”数据库“；当今时代数据爆炸，面对巨额的数据，我们创造了数据库这个在线的结构来处理，管理这些数据。而SQL就是一种结构化的数据库操作语言，它使得我们能够高效，准确的获取，修改，操作数据库中我们需要的数据。\n0x01：SQL基本处理与对应语法 link从上一个部分，我们可以把SQL分成以下几个部分\n1.DDL(Data Definition Language)数据定义语言，用来定义数据库对象(库 表 列…)\n2.DML(Data Manipulation Language)数据操作语言，用来操作数据库中的数据\n3.DCL(Data Control Language)数据控制语言，定义数据权限与安全问题\n4.DQL（Data Query Language）数据查询语言，查询数据\n我们一个一个来讲讲基本语法\n以下语法句子中关键字均采取大写处理\n1.DDL link库操作 link 创建数据库：CREATE DATABASE NAME；e.gCREATE DATABASE whustd，创建一个名为 whustd的数据库。如果这个数据已经存在，那么会报错。但是 CREATE DATABASE IF NOT EXISTS whustd，在名为 whustd 的数据库不存在时创建该库，这样可以避免报错。\n删除数据库：DROP DATABASE [IF EXISTS] NAME；e.g DROP DATABASE whustd，删除名为 WHUSTD 的数据库。如果这个数据库不存在，那么会报错。同理 DROP DATABASE IF EXISTS WHUSTD，就算 WHUSTD不存在，也不会的报错。\n修改数据库编码：ALTER DATABASE whustd CHARACTER SET utf8 修改数据库 WHUSTD 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都 不能使用中间的“-”，即 UTF-8 要书写为 UTF8。 修改编码一般是处理非英文内容的编译防止出现乱码。\n常用数据类型 link int：整型\ndouble：浮点型，例如 double(5,2)表示最多 5 位，其中必须有 2 位小数，即最大值为 999.99；\ndecimal：泛型型，在表单线方面使用该类型，因为不会出现精度缺失问题；\nchar：固定长度字符串类型；(当输入的字符不够长度时会补空格)\nvarchar：固定长度字符串类型；\ntext：字符串类型；\nblob：字节类型；\ndate：日期类型，格式为：yyyy-MM-dd；\ntime：时间类型，格式为：hh:mm:ss\ntimestamp：时间戳类型；\n表操作 link CREATE TABLE 表名 (列名 列类型, 列名 列类型, ...... ); e.g\nCREATE TABLE whustd( ​\tsid CHAR(6), (sid:服务器安全标识，长度为固定6个字符，不足用空格补足（char）) ​\tsname VARCHAR(20), （sname 即名字，不用name是因为部分数据库的内容中name是保留字；varchar则是可变长度的字符串，最高不超过20即可 ） ​\tage INT, （年龄，整数形） ​\tgender VARCHAR(10) （性别，male/female） ); 查看表的结构 DESC 表名;\n删除表 DROP TABLE 表名;\n修改表 ALTER TABLE whustd ADD (classname varchar(100));\n添加列：给 whustd 表添加 classname 列\n修改列的数据类型： ALTER TABLE whustd MODIFY gender CHAR(2);\n修改 whustd 表的 gender 列类型为 CHAR(2)\nALTER TABLE whustd change gender sex CHAR(2);\n修改列名：修改 whustd 表的 gender 列名为 sex\nALTER TABLE whustd DROP classname;\n删除列：删除 whustd 表的 classname 列\nALTER TABLE whustd RENAME TO student;\n修改表名称：修改 whustd 表名称为 student\n2.DML link1.插入数据 link 语法 1： INSERT INTO 表名(列名 1,列名 2, …) ;\nINSERT INTO whustd(sid, sname,age,gender) VALUES('s_1001', 'zhangSan', 23, 'male');\n给sid,sname,age,gender赋值为’s_1001’, ‘zhangSan’, 23, ‘male’\nINSERT INTO whustd(sid, sname) VALUES('s_1001', 'zhangSan');\n同上\n语法 2： INSERT INTO 表名 VALUES(值 1,值 2,…);\n因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：\nINSERT INTO stu VALUES('s_1002', 'liSi', 32, 'female');\n按照sid, sname,age,gender默认顺序来赋值\n2.修改数据 link语法：\nUPDATE 表名 SET 列名 1=值 1, … 列名 n=值 n [WHERE 条件];\n例子\nUPDATE whustd SET sname=’zhangSanSan’, age=’32’, gender=’female’ WHERE sid=’s_1001’; UPDATE whustd SET sname=’liSi’, age=’20’**WHERE** age\u003e50 AND gender=’male’;(条件) UPDATE whustd SET sname=’wangWu’, age=’30’WHERE age\u003e60 OR gender=’female’; UPDATE whustd SET gender=’female’WHERE gender IS NULL UPDATE whustd SET age=age+1 WHERE sname=’zhaoLiu’; 3.删除数据 link 语法 1： DELETE FROM 表名 [WHERE 条件];\nDELETE FROM whustd WHERE sid=’s_1001’003B; DELETE FROM whustd WHERE sname=’chenQi’ OR age \u003e 30; DELETE FROM whustd; 语法 2： TRUNCATE TABLE 表名;\nTRUNCATE TABLE whustd;\n两者之间的区别： 虽然 TRUNCATE 和 DELETE 都可以删除表的所有记录，但有原理不同。DELETE的效率没有 TRUNCATE 高！\nTRUNCATE 其实属性 DDL 语句，因为它是先 DROP TABLE，再 CREATE TABLE。\n而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的\n3.DCL link1.创建用户 link语法：\nCREATE USER ‘用户名’@地址 IDENTIFIED BY '密码';\n这里这个地址表示主机标识，即用户可以从那些设备连接到数据库\nCREATE USER ‘user1’@localhost IDENTIFIED BY ‘123’;（创造一个用户，通过本地主机访问，密码为123） CREATE USER ‘user2’@’%’ IDENTIFIED BY ‘123’;（不限制访问设备） 2.给用户授权 link语法：\nGRANT 权限 1, … , 权限 n ON 数据库.* TO ‘用户名’@地址;\nGRANT *CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT* ON whustd.* TO 'user1'@localhost; GRANT ALL ON whustd.* TO user2@localhost; 3.撤销授权 link语法：\nREVOKE 权限 1, … , 权限 n ON 数据库.* FROM ‘用户名’@地址; 例如：\nREVOKE CREATE,ALTER,DROP ON whustd.* FROM 'user1'@localhost;\n4.查看用户权限 link语法：\nSHOW GRANTS FOR ‘用户名’@地址;\nSHOW GRANTS FOR 'user1'@localhost;\n5.删除用户 link语法：\nDROP USER ‘用户名’@地址;\nDROP USER ‘user1’@localhost;\n6.修改用户密码（以root身份） link语法 ：\nuse mysql; alter user '用户名'@localhost identified by '新密码'; 4.DQL link1.基础查询 link 查询所有列 SELECT * FROM 表名;\n(* ：通配符，表示所有列)\nSELECT * FROM whustd;\n查询指定列 SELECT 列名 1, 列名 2, …列名 n FROM 表名;\nSELECT sid, sname, age FROM whustd;\n2.条件查询 link 条件查询就是在查询时给出 WHERE 子句，在 WHERE 子句中可以使用如下运算符及关键字：\n=、!=、\u003c\u003e、\u003c、\u003c=、\u003e、\u003e=；\rBETWEEN…AND；\rIN(set)；\rIS NULL；\rAND；\rOR；\rNOT； 3.模糊查询 linkSELECT 字段 FROM 表 WHERE 某字段 Like 条件\n其中关于条件，SQL 提供了两种匹配模式：\n‘’%’’ ：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情 况下若是中文，请使用两个百分号（%%）表示。\n“_\"： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字 符长度语句。 .4.字段控制查询 link 给列名添加别名 SELECT *, oldname (AS) newname FROM whustd;\n给列起别名时，是可以省略 AS 关键字的：\nSELECT *, oldname newname FROM whustd;\n5.排序 link 查询所有学生记录，按年龄升序排序 SELECT * FROM whustd ORDER BY sage ASC; 或者\nSELECT * FROM whustd ORDER BY sage; 再或者查询所有学生记录，按年龄降序排序 SELECT * FROM whustd ORDER BY age DESC; 6.聚合函数 link聚合函数是用来做纵向运算的函数：\nCOUNT()：统计指定列不为 NULL 的记录行数；\nMAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\nMIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\nSUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为 0；\nAVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为 0；\nCOUNT：当需要纵向统计时可以使用 COUNT()。\nSUM 和 AVG：当需要纵向求和时使用 sum()函数。\n"
            }
        );
    index.add(
            {
                id:  10 ,
                href: "\/docs\/",
                title: "Docs",
                description: "",
                content: ""
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
        
    </body>
</html>
