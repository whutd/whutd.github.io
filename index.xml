<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>whutd blog</title>
    <link>https://whutd.github.io/</link>
    <description>Recent content on whutd blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://whutd.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【图论】单源最短路问题</title>
      <link>https://whutd.github.io/docs/%E5%9B%BE%E8%AE%BA%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/%E5%9B%BE%E8%AE%BA%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h2 id=&#34;0x01-问题描述&#34;&gt;0x01 问题描述 &lt;a href=&#34;#0x01-%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;给定 n 个点，m 条有向边的带非负权图，请你计算从起点 s 出发，到每个点的距离。数据保证你能从 s 出发到任意点。&#xA;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4779&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;原链接&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&amp;quot;&#xA;lastmod: &amp;ldquo;2024-12-12T00:35:&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x02-前置知识c语言图的构建&#34;&gt;0x02 前置知识：C语言图的构建 &lt;a href=&#34;#0x02-%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86c%e8%af%ad%e8%a8%80%e5%9b%be%e7%9a%84%e6%9e%84%e5%bb%ba&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;既然想要解决这个问题，我们首先要明白的是如何在C语言中将一个图来表示出来。这里提供两种方法。当然两种方法的原理是互通的,所以其实理解一种剩下一种也不难看懂。&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-链式前向星&#34;&gt;1. 链式前向星 &lt;a href=&#34;#1-%e9%93%be%e5%bc%8f%e5%89%8d%e5%90%91%e6%98%9f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&#xA;&lt;li&gt;核心代码1（图的存储方式）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int head[N];//head[i]中存储第i个的第一条边的编号&#xD;&#xA;int cnt=0;//用来计算边的数量&#xD;&#xA;struct EDGE &#xD;&#xA;{&#xD;&#xA;    int next;&#xD;&#xA;    int to;//next指向该边起点连的下一条边的编号，to是指这条边的终点,当然可以为这个结构体添加更多变量来存储这条边更多的信息，看题目的具体要求&#xD;&#xA;}edge[M];//此处假定点最多为N个而边最多为M条&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;好的，那么我们如何向里面来添加边，从而真正的做成一个图呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>【字符串】kmp算法</title>
      <link>https://whutd.github.io/docs/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/%E5%AD%97%E7%AC%A6%E4%B8%B2kmp%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;作用&#34;&gt;作用 &lt;a href=&#34;#%e4%bd%9c%e7%94%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;用于&lt;strong&gt;快速&lt;/strong&gt;快速查找模式串（子串）&lt;code&gt;pattern&lt;/code&gt;在主串（母串）&lt;code&gt;main&lt;/code&gt;中出现的位置。&lt;/p&gt;&#xA;&lt;p&gt;注意，此处是匹配子串的要求，而子串是连续的&lt;/p&gt;&#xA;&lt;h2 id=&#34;原理&#34;&gt;原理 &lt;a href=&#34;#%e5%8e%9f%e7%90%86&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h4 id=&#34;前置知识前缀函数&#34;&gt;前置知识：前缀函数 &lt;a href=&#34;#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86%e5%89%8d%e7%bc%80%e5%87%bd%e6%95%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;对于一个字符串，将它 &lt;em&gt;不包含自身的前后缀（称为真前后缀）&lt;/em&gt; 罗列出来，找到匹配的前后缀，取它们长度的最大值称之为 &lt;em&gt;最长匹配真前后缀的长度&lt;/em&gt;，此过程记为函数$π$&lt;/p&gt;&#xA;&lt;p&gt;例如：对于字符串 $s=$&lt;code&gt;ATAATA&lt;/code&gt;&#xA;含有真前缀为&lt;code&gt;ATAAT&lt;/code&gt; &lt;code&gt;ATAA&lt;/code&gt; &lt;code&gt;ATA&lt;/code&gt; &lt;code&gt;AT&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;∅&lt;/code&gt;&#xA;含有真后缀为&lt;code&gt;TAATA&lt;/code&gt; &lt;code&gt;AATA&lt;/code&gt; &lt;code&gt;ATA&lt;/code&gt; &lt;code&gt;TA&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;∅&lt;/code&gt;&#xA;匹配的前后缀有&lt;code&gt;ATA&lt;/code&gt;，&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;∅&lt;/code&gt;，长度分别为$3、1、0$&#xA;则字符串&lt;code&gt;ATAATA&lt;/code&gt;的$π$值为$3$&lt;/p&gt;&#xA;&lt;p&gt;然后将字符串的所有非空前缀列出来，从$0$开始编号，并计算这些前缀的$π$值，将它们存在一个数组里，这就是&lt;strong&gt;前缀函数&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;字符串&lt;code&gt;ATAATA&lt;/code&gt;的前缀函数数组如下&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;下标 $i$&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;0&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;1&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;2&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;3&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;4&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;5&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;前缀字符串&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;AT&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;ATA&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;ATAA&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;ATAAT&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;ATAATA&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$π[i]$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$0$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$0$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$1$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$1$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$2$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$3$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;即$π[i]$就是子串 $s[0&amp;hellip;i]$ 最长匹配真前后缀的长度&lt;/p&gt;&#xA;&lt;h4 id=&#34;kmp原理&#34;&gt;kmp原理 &lt;a href=&#34;#kmp%e5%8e%9f%e7%90%86&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;如果将主串&lt;code&gt;main&lt;/code&gt;和模式串&lt;code&gt;pattern&lt;/code&gt;以一个特殊字符&lt;code&gt;#&lt;/code&gt;链接在一起&#xA;并计算这个字符串的前缀函数，如果存在$π[i]$等于&lt;code&gt;pattern&lt;/code&gt;的长度，则说明找到了和模式串匹配的子串，且长度为$π[i]$的后缀字符串与&lt;code&gt;pattern&lt;/code&gt;完全相同。&lt;/p&gt;&#xA;&lt;p&gt;设&lt;code&gt;main&lt;/code&gt;=&lt;code&gt;AGCATAATAATTAA&lt;/code&gt;，&lt;code&gt;pattern&lt;/code&gt;=&lt;code&gt;ATAATA&lt;/code&gt;，则合并串&lt;code&gt;s&lt;/code&gt;=&lt;code&gt;ATAATA#AGCATAATAATTAA&lt;/code&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;合并串&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;T&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;T&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;#&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;G&lt;/th&gt;&#xA;          &lt;th&gt;C&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;T&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;T&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;T&lt;/th&gt;&#xA;          &lt;th&gt;T&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;          &lt;th&gt;A&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$i$&lt;/td&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;7&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;9&lt;/td&gt;&#xA;          &lt;td&gt;10&lt;/td&gt;&#xA;          &lt;td&gt;11&lt;/td&gt;&#xA;          &lt;td&gt;12&lt;/td&gt;&#xA;          &lt;td&gt;13&lt;/td&gt;&#xA;          &lt;td&gt;14&lt;/td&gt;&#xA;          &lt;td&gt;15&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;17&lt;/td&gt;&#xA;          &lt;td&gt;18&lt;/td&gt;&#xA;          &lt;td&gt;19&lt;/td&gt;&#xA;          &lt;td&gt;20&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$π[i]$&lt;/td&gt;&#xA;          &lt;td&gt;$0$&lt;/td&gt;&#xA;          &lt;td&gt;$0$&lt;/td&gt;&#xA;          &lt;td&gt;$1$&lt;/td&gt;&#xA;          &lt;td&gt;$1$&lt;/td&gt;&#xA;          &lt;td&gt;$2$&lt;/td&gt;&#xA;          &lt;td&gt;$3$&lt;/td&gt;&#xA;          &lt;td&gt;$0$&lt;/td&gt;&#xA;          &lt;td&gt;$1$&lt;/td&gt;&#xA;          &lt;td&gt;$0$&lt;/td&gt;&#xA;          &lt;td&gt;$0$&lt;/td&gt;&#xA;          &lt;td&gt;$1$&lt;/td&gt;&#xA;          &lt;td&gt;$2$&lt;/td&gt;&#xA;          &lt;td&gt;$3$&lt;/td&gt;&#xA;          &lt;td&gt;$4$&lt;/td&gt;&#xA;          &lt;td&gt;$5$&lt;/td&gt;&#xA;          &lt;td&gt;$6$&lt;/td&gt;&#xA;          &lt;td&gt;$4$&lt;/td&gt;&#xA;          &lt;td&gt;$5$&lt;/td&gt;&#xA;          &lt;td&gt;$0$&lt;/td&gt;&#xA;          &lt;td&gt;$1$&lt;/td&gt;&#xA;          &lt;td&gt;$1$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;可以看到$π[15]=6$，的确$s[0&amp;hellip;i]=$&lt;code&gt;ATAATA#AGCATAATA&lt;/code&gt;,前六个字符（即模式串）与后六个字符（主串的一个子串）完全相同，即在主串中找到了模式串。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AES密码算法</title>
      <link>https://whutd.github.io/docs/aes%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/aes%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;aes密码算法&#34;&gt;AES密码算法 &lt;a href=&#34;#aes%e5%af%86%e7%a0%81%e7%ae%97%e6%b3%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h1&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;小声bb：某只学了一学期c语言程序设计、没有计算机基础、数学水平只有一学期的高等数学和线性代数、没有任何密码学基础的大一新生被抛给了一个博客任务，临时抱佛脚学习了这个密码算法。笔者水平有限，如有疏漏望谅解和指正，并希望能帮助到其他的初中级学习者。&#xA;&lt;strong&gt;注&lt;/strong&gt;：本篇更注重算法的 &lt;strong&gt;应用和实现方法&lt;/strong&gt; 而非数学基础。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;引言&#34;&gt;引言 &lt;a href=&#34;#%e5%bc%95%e8%a8%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;AES是美国政府公开征集的数据加密标准算法，用以取代DES，经过筛选，最终选出 &lt;strong&gt;RIJNDAEL&lt;/strong&gt; 算法作为AES。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-加密算法&#34;&gt;1 加密算法 &lt;a href=&#34;#1-%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;10-最初步的处理&#34;&gt;1.0 最初步的处理 &lt;a href=&#34;#10-%e6%9c%80%e5%88%9d%e6%ad%a5%e7%9a%84%e5%a4%84%e7%90%86&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;ASE算法在对明文加密的时候，并不是把整个明文一股脑的加密成一整段密文，而是把明文 &lt;strong&gt;拆分&lt;/strong&gt; 成一个个独立的明文块，每一个明文块长度&lt;strong&gt;128 bit&lt;/strong&gt;（16个字节，也就是两个十六进制数字）。这些明文经过ASE加密器的复杂处理，生成一个个独立的密文块，这些密文块 &lt;strong&gt;拼接&lt;/strong&gt; 在一起，就是最终的ASE加密结果。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;假如一段明文长度是192 bit，如果按每128 bit一个明文块来拆分的话，第二个明文块只有 64bit，不足128 bit，就需要对明文块进行填充。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;11-加密算法构成&#34;&gt;1.1 加密算法构成 &lt;a href=&#34;#11-%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e6%9e%84%e6%88%90&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;RIJNDAEL算法采用的是分组密码的一种通用结构：对轮函数实施迭代。&#xA;轮函数结构采用的是代替/置换网络结构（SP结构），由非线性层 &lt;code&gt;S盒变换ByteSub&lt;/code&gt;、线性混合层 &lt;code&gt;行移位ShiftRow&lt;/code&gt; 和 &lt;code&gt;列混合MixColumn&lt;/code&gt;、密钥加层 &lt;code&gt;轮密钥加变换AddRoundKey&lt;/code&gt;，这三层构成。&lt;/p&gt;&#xA;&lt;p&gt;算法构成可以描述为下图情况：&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;用语言整体叙述一下这个流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;我们首先投入主密钥和明文&lt;/li&gt;&#xA;&lt;li&gt;将主密钥进行 &lt;code&gt;密钥扩展KeyExpansion&lt;/code&gt;，扩展成为Nr+1个子密钥 (Nr的取值见1.3.0)&lt;/li&gt;&#xA;&lt;li&gt;用第1个子密钥对明文做  初始&lt;code&gt;轮密钥加变换AddRoundKey&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;对该状态依次做&lt;code&gt;S盒变换ByteSub&lt;/code&gt;、&lt;code&gt;行移位ShiftRow&lt;/code&gt;、&lt;code&gt;列混合MixColumn&lt;/code&gt;、用第 &lt;strong&gt;i&lt;/strong&gt; 个子密钥做 &lt;code&gt;轮密钥加变换AddRoundKey&lt;/code&gt;。&#xA;&lt;strong&gt;注意：该步骤重复Nr轮，i 分别在每一轮取2，3,&amp;hellip;,Nr+1。其中最后一轮不做&lt;code&gt;列混合MixColumn&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;得到最终密文&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;代码：&lt;/p&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AES_Encrypt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; plaintext[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ciphertext[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; roundKeys[&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; numberOfRounds) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; state[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 将明文复制到状态数组&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        state[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plaintext[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 初始轮：加轮密钥&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;AddRoundKey&lt;/span&gt;(state, roundKeys, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 主循环：执行多轮加密操作&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; round &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; round &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; numberOfRounds; round&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;SubBytes&lt;/span&gt;(state);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;ShiftRows&lt;/span&gt;(state);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;MixColumns&lt;/span&gt;(state);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;AddRoundKey&lt;/span&gt;(state, roundKeys, round);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 最终轮（不包含MixColumns步骤）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;SubBytes&lt;/span&gt;(state);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ShiftRows&lt;/span&gt;(state);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;AddRoundKey&lt;/span&gt;(state, roundKeys, numberOfRounds); &lt;span style=&#34;color:#75715e&#34;&gt;// 注意：这里的轮数应该是总轮数，但在实际代码中，我们可能使用roundKeys[numberOfRounds-1]，因为轮密钥数组索引是从0开始的&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 将加密后的状态复制到密文字数组&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ciphertext[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; state[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;p&gt;下面来详细介绍一下每个步骤的操作&lt;/p&gt;</description>
    </item>
    <item>
      <title>ARP攻击</title>
      <link>https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB/</guid>
      <description>&lt;h2 id=&#34;0x00-osi模型&#34;&gt;0x00 OSI模型 &lt;a href=&#34;#0x00-osi%e6%a8%a1%e5%9e%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在开放系统互连（OSI）参考模型中，网络工作被划分为七个层次。各层之间并不直接进行交互，而是仅通过层接口（Layer Interface）实现彼此间的通信。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;IP地址在第三层（网络层）, MAC地址在第二层（数据链路层）。协议在发送数据包时，首先要封装第三层（IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务拿到MAC地址。&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x01-arp协议&#34;&gt;0x01 ARP协议 &lt;a href=&#34;#0x01-arp%e5%8d%8f%e8%ae%ae&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x02-arp攻击&#34;&gt;0x02 ARP攻击 &lt;a href=&#34;#0x02-arp%e6%94%bb%e5%87%bb&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;1表现&#34;&gt;1.表现 &lt;a href=&#34;#1%e8%a1%a8%e7%8e%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一般情况下，受到ARP攻击的计算机会出现两种现象：&lt;br&gt;&#xA;不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。&lt;br&gt;&#xA;计算机不能正常上网，出现网络中断的症状。&lt;br&gt;&#xA;除此之外，用户可能还会遭遇信息泄露的情况。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2原理&#34;&gt;2.原理 &lt;a href=&#34;#2%e5%8e%9f%e7%90%86&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;ARP协议是TCP/IP协议组的一个协议，这个协议是建立在局域网上主机相互信任的基础上的，局域网中的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性并直接将其记入本机ARP缓存。ARP缓存表采用的是机械制原理，如果表中的某一列长时间不使用，就会被删除。也就是说ARP的缓存表是可以被更改的。表中的IP地址和MAC地址也是随时可以修改，这样在局域网中很容易被ARP欺骗。&lt;/p&gt;&#xA;&lt;p&gt;在网络通信过程中，当客户机向外部网络发送数据包时，首先会借助ARP协议来获取网关的MAC地址。之后，客户机会将 IP 数据包封装在以太网帧中，并发送给该网关，由网关负责后续的转发工作。&lt;br&gt;&#xA;然而，网络环境并非绝对安全。当有恶意人员接入网络后，会对网络中的 ARP 流量进行监听。由于 ARP 地址解析请求采用广播的方式发送，网络中的所有参与者都能够接收到该请求，黑客自然也不例外。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;https://whutd.github.io/dfee62b16526cbf7fa8a35d0fc8dfe290c188432_11414023627677143472.png&#34; alt=&#34;&#34; width=&#34;1500&#34; height=&#34;988&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;以 PC 解析网关 192.168.50.1 的 MAC 地址这一过程为例。当黑客嗅探到 ARP 请求后，可能会实施恶意行为。黑客会伪装成网关，伪造 ARP 应答信息来欺骗 PC。PC 在接收到 ARP 应答后，会将应答结果存储在 ARP 缓存中。由于 ARP 协议缺乏有效的校验机制，PC 很容易受到黑客的欺骗。需要注意的是，网关也会向 PC 发送真实的 ARP 应答。在此情况下，PC 会依据系统协议栈的规则来采信应答信息，而系统协议栈通常以最新接收到的应答作为有效信息。&lt;br&gt;&#xA;黑客在嗅探到 ARP 请求后，会持续发送虚假应答，总有一个虚假应答能够覆盖网关发送的真实应答，从而进入 PC 的 ARP 缓存表。这种攻击方式被称为 ARP 泛洪（ARP Flooding）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ARP攻击详解</title>
      <link>https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/arp%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;0x00-什么是arp协议&#34;&gt;0x00 什么是ARP协议 &lt;a href=&#34;#0x00-%e4%bb%80%e4%b9%88%e6%98%afarp%e5%8d%8f%e8%ae%ae&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ARP（Address Resolution Protocol，地址解析协议）是TCP/IP协议栈中网络层的重要协议之一，主要用于将IP地址解析为对应的MAC地址，以便设备在局域网内正常通信。&lt;br&gt;&#xA;在局域网中，通信通常依赖于MAC地址，ARP的基本工作流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;设备A需要发送数据给设备B，它知道设备B的IP地址，但是不知道设备B的MAC地址；&lt;/li&gt;&#xA;&lt;li&gt;设备A发送一个ARP请求，询问哪个设备对应IP地址是设备B；&lt;/li&gt;&#xA;&lt;li&gt;设备B收到ARP请求后，回复设备A一个包含自己MAC地址的ARP响应；&lt;/li&gt;&#xA;&lt;li&gt;设备A将这个IP和MAC的对应关系存储在自己的ARP缓存中，以后可以直接使用。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;举个栗子：我想去腾讯总部（IP地址）,但不知道具体位置（MAC地址）,这时我就可以通过导航软件(ARP)找到腾讯大厦。&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;示意图如下：&lt;/p&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sequenceDiagram&#xD;&#xA;A-&amp;gt;&amp;gt;Network: 广播ARP请求&#xD;&#xA;Network-&amp;gt;&amp;gt;B: 转发请求&#xD;&#xA;B-&amp;gt;&amp;gt;A: 返回目标MAC地址&#xD;&#xA;A-&amp;gt;&amp;gt;Cache: 存储IP-MAC映射&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x01-什么是arp攻击&#34;&gt;0x01 什么是ARP攻击 &lt;a href=&#34;#0x01-%e4%bb%80%e4%b9%88%e6%98%afarp%e6%94%bb%e5%87%bb&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ARP攻击利用了ARP协议本身的一个漏洞：ARP协议没有任何验证机制，攻击者可以伪造ARP请求或响应，欺骗网络中的设备，使其将错误的MAC地址绑定到一个合法的IP地址。这样攻击者就可以拦截、修改甚至伪造网络中的数据。&#xA;常见的ARP攻击方式有以下几种：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;ARP欺骗&lt;/strong&gt;：伪造ARP响应，欺骗目标设备，将攻击者的MAC地址绑定到合法设备的IP地址；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;中间人攻击（MITM）&lt;/strong&gt;：通过ARP欺骗将自己伪装成通信双方，实现对数据包的监听和篡改；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ARP泛洪攻击&lt;/strong&gt;：大量发送伪造的ARP响应，填满目标设备的ARP缓存，导致网络异常。&#xA;示意图如下:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sequenceDiagram&#xD;&#xA;    Attacker-&amp;gt;&amp;gt;A: 伪造ARP响应（假冒网关）&#xD;&#xA;    A-&amp;gt;&amp;gt;Cache: 更新IP-MAC映射（错误）&#xD;&#xA;    A-&amp;gt;&amp;gt;Attacker: 发送数据（实际应发往网关）&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x02-arp攻击的危害&#34;&gt;0x02 ARP攻击的危害: &lt;a href=&#34;#0x02-arp%e6%94%bb%e5%87%bb%e7%9a%84%e5%8d%b1%e5%ae%b3&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;ARP攻击的危害包括但不限于：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;流量劫持&lt;/strong&gt;：攻击者可以截获目标设备的网络流量，窃取敏感信息；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络瘫痪&lt;/strong&gt;：通过ARP泛洪攻击使设备无法正常通信；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据篡改&lt;/strong&gt;：攻击者可在通信过程中篡改数据包内容，进行恶意操作。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;0x03-如何防范arp攻击&#34;&gt;0x03 如何防范ARP攻击 &lt;a href=&#34;#0x03-%e5%a6%82%e4%bd%95%e9%98%b2%e8%8c%83arp%e6%94%bb%e5%87%bb&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;尽管ARP协议本身缺乏安全性，但可以通过以下方式降低ARP攻击的风险：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;静态ARP表&lt;/strong&gt;：手动将设备的IP地址和MAC地址绑定起来，避免被伪造的ARP响应修改。这种方法适用于重要的设备（如服务器、网关等）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Windows中设置静态ARP表：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 查看当前的ARP缓存&#xD;&#xA;arp -a&#xD;&#xA;# 添加静态ARP条目，手动绑定IP和MAC地址&#xD;&#xA;arp -s 192.168.1.1 00-11-22-33-44-55&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;启用ARP绑定&lt;/strong&gt;：部分路由器支持将IP地址与MAC地址绑定。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用VLAN&lt;/strong&gt;：通过划分虚拟局域网，隔离不同设备之间的通信。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络监控工具&lt;/strong&gt;：利用工具如Wireshark或arpwatch监控ARP异常。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;安全协议&lt;/strong&gt;：使用HTTPS、SSH等加密协议，确保即使数据被拦截，也不会泄露敏感信息,防止敏感信息泄露。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;0x04-实例分析arp攻击的模拟与防护&#34;&gt;0x04 实例分析:ARP攻击的模拟与防护 &lt;a href=&#34;#0x04-%e5%ae%9e%e4%be%8b%e5%88%86%e6%9e%90arp%e6%94%bb%e5%87%bb%e7%9a%84%e6%a8%a1%e6%8b%9f%e4%b8%8e%e9%98%b2%e6%8a%a4&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;下面我们通过一个简单的例子来演示如何进行ARP攻击，并介绍如何防护。&#xA;&lt;strong&gt;1. 环境准备&lt;/strong&gt;&#xA;假设我们有三台设备：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设备A（IP地址：192.168.1.100）是受害者；&lt;/li&gt;&#xA;&lt;li&gt;设备B（IP地址：192.168.1.1）是网关；&lt;/li&gt;&#xA;&lt;li&gt;设备C（IP地址：192.168.1.200）是攻击者。&#xA;攻击工具：arpspoof（一般在Kali Linux中使用，但Windows下可以通过Cygwin或WSL模拟Linux环境）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. ARP攻击步骤&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git报错与修改历程</title>
      <link>https://whutd.github.io/docs/git%E6%8A%A5%E9%94%99%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%8E%86%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/git%E6%8A%A5%E9%94%99%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%8E%86%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;1报错情景&#34;&gt;1.报错情景 &lt;a href=&#34;#1%e6%8a%a5%e9%94%99%e6%83%85%e6%99%af&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;某日打开电脑，想要&lt;code&gt;git pull&lt;/code&gt;一下云端代码，发现如下报错&lt;/p&gt;&#xA;&lt;p&gt;![image-20250204103956684](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204103956684.png)&lt;/p&gt;&#xA;&lt;p&gt;显示连接超时，尝试了&lt;code&gt;git clone&lt;/code&gt; 与&lt;code&gt;git push&lt;/code&gt;好像都用不了了，但是还能正常访问Github&lt;/p&gt;&#xA;&lt;p&gt;使用&lt;code&gt;ssh -T git@github.com&lt;/code&gt;来查看链接情况&lt;/p&gt;&#xA;&lt;p&gt;![image-20250204104404309](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204104404309.png)&lt;/p&gt;&#xA;&lt;p&gt;这种情况就是22端口被占用&lt;/p&gt;&#xA;&lt;h2 id=&#34;2解决方式&#34;&gt;2.解决方式 &lt;a href=&#34;#2%e8%a7%a3%e5%86%b3%e6%96%b9%e5%bc%8f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;1使用https连接&#34;&gt;（1）.使用HTTPS连接 &lt;a href=&#34;#1%e4%bd%bf%e7%94%a8https%e8%bf%9e%e6%8e%a5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git config --local -e&lt;/code&gt;打开本地git 配置文件&lt;/p&gt;&#xA;&lt;p&gt;![image-20250204110813289](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204110813289.png)&lt;/p&gt;&#xA;&lt;p&gt;把这段使用&lt;code&gt;git@github.com&lt;/code&gt;的SSH链接改为&lt;/p&gt;&#xA;&lt;p&gt;![image-20250204110849275](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204110849275.png)&lt;/p&gt;&#xA;&lt;p&gt;HTTPS的链接&lt;/p&gt;&#xA;&lt;h3 id=&#34;2尝试切换端口&#34;&gt;（2）.尝试切换端口 &lt;a href=&#34;#2%e5%b0%9d%e8%af%95%e5%88%87%e6%8d%a2%e7%ab%af%e5%8f%a3&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;访问电脑路径&lt;code&gt;C:\Users\%你的用户名%\.ssh&lt;/code&gt;![image-20250204105222170](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204105222170.png)&lt;/p&gt;&#xA;&lt;p&gt;如果没有config文件，就打开vscode创建一个，粘贴如下配置进去&lt;/p&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-config&#34; data-lang=&#34;config&#34;&gt;Host github.com&#xD;&#xA;User git&#xD;&#xA;Hostname ssh.github.com&#xD;&#xA;PreferredAuthentications publickey&#xD;&#xA;IdentityFile ~/.ssh/id_rsa&#xD;&#xA;Port 443&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;即使用443端口访问github，保存&lt;/p&gt;&#xA;&lt;p&gt;再使用&lt;code&gt;ssh -T git@github.com&lt;/code&gt;来尝试访问github&lt;/p&gt;&#xA;&lt;p&gt;![image-20250204105526091](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204105526091.png)&lt;/p&gt;&#xA;&lt;p&gt;提示重新建立连接，输入yes&lt;/p&gt;&#xA;&lt;p&gt;此时可以正常&lt;code&gt;git clone&lt;/code&gt;,再&lt;code&gt;git pull&lt;/code&gt;，发现仍然无法成功&lt;/p&gt;&#xA;&lt;h3 id=&#34;3重新修改ssh密钥&#34;&gt;（3）.重新修改ssh密钥 &lt;a href=&#34;#3%e9%87%8d%e6%96%b0%e4%bf%ae%e6%94%b9ssh%e5%af%86%e9%92%a5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;注意到这里![image-20250204111656269](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204111656269.png)&lt;/p&gt;&#xA;&lt;p&gt;经过查询是修改端口后ssh密钥不匹配，于是重新生成对应的密钥,输入指令&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa -C “your_email.com”&lt;/code&gt;![image-20250204111807116](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204111807116.png)&lt;/p&gt;&#xA;&lt;p&gt;![image-20250204111836436](C:\Users\gao ancheng\AppData\Roaming\Typora\typora-user-images\image-20250204111836436.png)&lt;/p&gt;</description>
    </item>
    <item>
      <title>RSA算法讲解</title>
      <link>https://whutd.github.io/docs/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/rsa%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;一、生成密钥的基本步骤&lt;/strong&gt;&#xA;$\textcircled {1}$ 寻找两个质数&lt;code&gt;p&lt;/code&gt; &lt;code&gt;q&lt;/code&gt;&#xA;$\textcircled {2}$ 两个质数相乘计算&lt;code&gt;N&lt;/code&gt;&#xA;&lt;code&gt;N = p * q&lt;/code&gt;&#xA;$\textcircled {3}$ 使用欧拉函数计算&lt;code&gt;T&lt;/code&gt;&#xA;&lt;code&gt;T = (p - 1)*(q - 1)&lt;/code&gt;&#xA;$\textcircled {4}$ 选择合适的公钥&lt;code&gt;E&lt;/code&gt; &lt;strong&gt;(注意：&lt;code&gt;E&lt;/code&gt;应该是一个质数，且不是&lt;code&gt;T&lt;/code&gt;的因子)&lt;/strong&gt;&#xA;$\textcircled {5}$ 计算生成私钥&lt;code&gt;D&lt;/code&gt; , 其中&lt;code&gt;D&lt;/code&gt;应当满足：&lt;code&gt;（D * E）% T = 1&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;经过上述操作，我们将得到&lt;strong&gt;公钥对&lt;/strong&gt;&lt;code&gt;（N, E）&lt;/code&gt;与&lt;strong&gt;私钥对&lt;/strong&gt;&lt;code&gt;(N, D)&lt;/code&gt;,其中我们采用公钥对对明文进行加密，用私钥对进行解密，加密与解密如下：&#xA;$$&#xA;明文^E % N = 密文\&#xA;密文^D % N = 明文\&#xA;$$&#xA;接下来我将具体讲解每个步骤的原理。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;二、寻找质数&lt;code&gt;p&lt;/code&gt; &lt;code&gt;q&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;随机数生成&#xA;&#xA;&#xA;    &#xA;    &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;random_num&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;srand&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;(NULL));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; bai_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rand&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;600&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//int p = (rand() % (max_t - min_t + 1)) + min_t;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; two_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rand&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rad_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bai_num &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; two_num;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; rad_num;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;这里我们采用C语言的&lt;code&gt;rand()&lt;/code&gt;函数，并且以&lt;strong&gt;时间为种子&lt;/strong&gt;生成随机数，注意到这里我&lt;strong&gt;生成了两个随机数&lt;/strong&gt;，原因是：&#xA;为了保证加密的安全性，我们通常选取的两个质数一般会比较大，这里我选择的是五位质数（实际上会更大），而计算机以时间种子在生成较大随机数时，&lt;strong&gt;很难保证生成的随机数的均匀分布&lt;/strong&gt;（&lt;strong&gt;即每次生成的大随机数很接近&lt;/strong&gt;），因此我将五位数的前三位和后两位&lt;strong&gt;分开随机生成&lt;/strong&gt;，可以确保生成的随机数在所给区间里的均匀分配&lt;/li&gt;&#xA;&lt;li&gt;判断生成的随机数是不是质数&#xA;这里我们采用&lt;code&gt;Miller Rabin素性检验&lt;/code&gt;,主要原理是利用了质数必然满足费马小定理，也即&lt;strong&gt;质数一定满足费马小定理，但是满足费马小定理的可能是伪素数&lt;/strong&gt;，但我们可以通过&lt;strong&gt;多次检验&lt;/strong&gt;来降低出错概率&#xA;参考文献： &lt;a href=&#34;https://zhuanlan.zhihu.com/p/349360074&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;Miller Rabin素性检验&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&#xA;代码如下：&#xA;&#xA;&#xA;    &#xA;    &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;miller_rabin_test&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 处理小数和偶数的情况&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 将 n - 1 表示为 d * 2^r&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ((d &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;d &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;r&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 执行 k 次测试&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; k; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rand&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mod_pow&lt;/span&gt;(a, d, n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&#x9;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mod_pow&lt;/span&gt;(x, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mod_pow&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; base, &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; exp, &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; mod) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; mod;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (exp &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (exp &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;&#x9;result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (result &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; base) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; mod;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;exp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exp &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#x9;base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (base &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; base) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; mod;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;通过以上办法我们成功找到了两个合适的质数&lt;code&gt;p&lt;/code&gt; &lt;code&gt;q&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>XSS 漏洞</title>
      <link>https://whutd.github.io/docs/godan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/godan/</guid>
      <description>&lt;h2 id=&#34;1-漏洞分析xss-漏洞的成因及攻击方式&#34;&gt;1. 漏洞分析：XSS 漏洞的成因及攻击方式 &lt;a href=&#34;#1-%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90xss-%e6%bc%8f%e6%b4%9e%e7%9a%84%e6%88%90%e5%9b%a0%e5%8f%8a%e6%94%bb%e5%87%bb%e6%96%b9%e5%bc%8f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;xss-漏洞的成因&#34;&gt;XSS 漏洞的成因 &lt;a href=&#34;#xss-%e6%bc%8f%e6%b4%9e%e7%9a%84%e6%88%90%e5%9b%a0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;XSS（Cross-Site Scripting）漏洞通常发生在 Web 应用程序未对用户输入进行充分的过滤或转义时。攻击者通过将恶意 JavaScript 代码嵌入到 Web 页面中，利用页面没有正确处理用户输入来执行恶意脚本，最终达到窃取用户信息、劫持会话、篡改页面内容等目的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;xss-漏洞的主要类型&#34;&gt;XSS 漏洞的主要类型 &lt;a href=&#34;#xss-%e6%bc%8f%e6%b4%9e%e7%9a%84%e4%b8%bb%e8%a6%81%e7%b1%bb%e5%9e%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反射型 XSS（Reflected XSS）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;攻击者将恶意脚本嵌入到 URL 或表单字段中，当用户访问该 URL 时，恶意脚本会立即在页面中反射执行。&lt;/li&gt;&#xA;&lt;li&gt;示例：&lt;code&gt;http://example.com/search?q=&amp;lt;script&amp;gt;alert(&#39;XSS&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;存储型 XSS（Stored XSS）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;攻击者将恶意脚本存储在服务器端（如论坛评论区、用户帖子等），当其他用户访问存储的内容时，恶意脚本被执行。&lt;/li&gt;&#xA;&lt;li&gt;示例：攻击者在评论区提交 &lt;code&gt;&amp;lt;script&amp;gt;alert(&#39;XSS&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt;，其他用户查看该评论时脚本执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;DOM 型 XSS（DOM-based XSS）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;攻击者通过操作网页上的 DOM 元素来触发脚本执行，而不是依赖服务器的响应。&lt;/li&gt;&#xA;&lt;li&gt;示例：通过修改 &lt;code&gt;window.location&lt;/code&gt; 或 &lt;code&gt;document.location&lt;/code&gt; 注入恶意代码。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;攻击方式&#34;&gt;攻击方式 &lt;a href=&#34;#%e6%94%bb%e5%87%bb%e6%96%b9%e5%bc%8f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;XSS 攻击的目标通常是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;窃取 Cookies&lt;/strong&gt;：攻击者通过脚本获取用户的 cookie 信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;窃取会话&lt;/strong&gt;：攻击者窃取会话标识符（如 Token），从而劫持用户会话。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;篡改页面内容&lt;/strong&gt;：修改页面 DOM，诱导用户点击恶意链接或输入信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;劫持用户输入&lt;/strong&gt;：通过恶意脚本记录用户的键盘输入或篡改表单数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-攻防技术介绍&#34;&gt;2. 攻防技术介绍 &lt;a href=&#34;#2-%e6%94%bb%e9%98%b2%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;攻击手段&#34;&gt;攻击手段 &lt;a href=&#34;#%e6%94%bb%e5%87%bb%e6%89%8b%e6%ae%b5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Payload 编写技巧&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;脚本注入&lt;/strong&gt;：常见的脚本 payload 如 &lt;code&gt;&amp;lt;script&amp;gt;alert(&#39;XSS&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt; 或嵌套多层 HTML 元素，如 &lt;code&gt;&amp;lt;img src=&amp;quot;x&amp;quot; onerror=&amp;quot;alert(&#39;XSS&#39;)&amp;quot;&amp;gt;&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;编码绕过&lt;/strong&gt;：利用 URL 编码、十六进制编码、Base64 编码等方式绕过过滤机制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DOM 操控&lt;/strong&gt;：利用 &lt;code&gt;document.write()&lt;/code&gt;、&lt;code&gt;innerHTML&lt;/code&gt; 等方法注入恶意脚本。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;免杀技术&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>大数乘法优化的几点方法</title>
      <link>https://whutd.github.io/docs/bigintcalc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/bigintcalc/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;悲剧地发现看不懂前面的推文后立志要写出只要是上过课的都能懂的文章。请懂的同学通过目录去了解自己有兴趣的内容，或者快速划过这篇推文。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h2 id=&#34;空间优化&#34;&gt;空间优化 &lt;a href=&#34;#%e7%a9%ba%e9%97%b4%e4%bc%98%e5%8c%96&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;压位&#34;&gt;压位 &lt;a href=&#34;#%e5%8e%8b%e4%bd%8d&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在获取大数字符串后需要以转换为整形存储，然而，如果数组里只存了1个数字未免有点浪费，所以我们可以进行压位操作，多存几个数字。以10进制存储的大数乘法运算一般压4位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;要注意的是，在例如 77x130=10010 的计算中，积在数组中的存储为[1，10]，输出结果就变成了110.为了避免这种结果，我们需要对输出格式进行一些处理：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;    &#xA;    &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int BigNumber_print(int*c,int top)//c为逆序存放乘积的数组，top为最高位下标&#xA;{&#xA;  printf(&amp;#34;%d&amp;#34;,c[top]);//最高位所在不能补零输出&#xA;  for(int i=top-1;i&amp;gt;=0;i--)&#xA;  {&#xA;    printf(&amp;#34;%04d&amp;#34;,c[i]);//将结果右对齐输出，结果补零，效果如：10-&amp;gt;0010&#xA;  }&#xA;  return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事实上，为了全bit存储以及后续部分算法的使用，我们可以将大数以2进制存储，这就需要2个将10进制转化为2进制的输入函数与将2进制转化为10进制的输出函数。这里不多做赘述。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;h2 id=&#34;时间优化&#34;&gt;时间优化 &lt;a href=&#34;#%e6%97%b6%e9%97%b4%e4%bc%98%e5%8c%96&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;karatsuba算法优化&#34;&gt;Karatsuba算法优化 &lt;a href=&#34;#karatsuba%e7%ae%97%e6%b3%95%e4%bc%98%e5%8c%96&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h4 id=&#34;先来做道竖式计算吧&#34;&gt;先来做道竖式计算吧 &lt;a href=&#34;#%e5%85%88%e6%9d%a5%e5%81%9a%e9%81%93%e7%ab%96%e5%bc%8f%e8%ae%a1%e7%ae%97%e5%90%a7&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;相信大家都做过这样的乘法列式计算题。&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;https://whutd.github.io/t0125d0d63253012912_5241267844418668949.jpg&#34; alt=&#34;竖式乘法计算&#34; width=&#34;400&#34; height=&#34;267&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&#xA;大数乘法的基本方法就是模拟手算乘法，简单，好想，空间复杂度小，时间复杂度为$O(n^2)$。&#xA;这个过程可以理解为：&#xA;($24\times10 + 0\times1) \times (3\times10 + 6\times1 ) = 72\times100 + (144+0)\times10+(0+6)\times1$&#xA;需要计算的乘法有：24x3、24x6、0x3、0x6&lt;/p&gt;&#xA;&lt;p&gt;如果把上面的过程抽象为字符形式：&#xA;($a \times x+b$)($c \times x+d$)=$ac · x^2+ (ad+bc) \times x+bd$&#xA;那么为了得出结果，我们需要知道ac、ad、bc、bd这4个乘法运算结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;关键的地方到了。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;易知：(a-b)(c-d)=ac+bd-(ad+bc)，若用ac+bd-(a-b)(c-d)来表示(ad+bc)的话，只需要计算3个乘法运算结果：(a-b)(c-d)、ac、bd。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h4 id=&#34;karatsuba算法的具体步骤&#34;&gt;Karatsuba算法的具体步骤 &lt;a href=&#34;#karatsuba%e7%ae%97%e6%b3%95%e7%9a%84%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;理解了上面的内容后，下面介绍Karatsuba算法的具体步骤：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;假设2个大数x、y的长度分别为p、q;&lt;/li&gt;&#xA;&lt;li&gt;取$n=min\lbrace p,q \rbrace$;&lt;/li&gt;&#xA;&lt;li&gt;将x、y表示为：$x=a·10^{n/2} + b；y=c·10^{n/2} + d$；&lt;/li&gt;&#xA;&lt;li&gt;计算$(a-b)(c-d)、ac、bd$；&lt;/li&gt;&#xA;&lt;li&gt;结果为：$ac·10^n+[ac+bd-(a-b)(c-d)]·10^{n/2}+bd$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;h4 id=&#34;karatsuba算法的程序实现&#34;&gt;Karatsuba算法的程序实现 &lt;a href=&#34;#karatsuba%e7%ae%97%e6%b3%95%e7%9a%84%e7%a8%8b%e5%ba%8f%e5%ae%9e%e7%8e%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;该算法可通过递归实现，需要提前写好大数加减算法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>漫谈SQL</title>
      <link>https://whutd.github.io/docs/%E6%BC%AB%E8%B0%88sql-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://whutd.github.io/docs/%E6%BC%AB%E8%B0%88sql-/</guid>
      <description>&lt;h2 id=&#34;0x00-sql是什么有什么用&#34;&gt;0x00 SQL是什么？有什么用？ &lt;a href=&#34;#0x00-sql%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;要谈谈SQL的定性，那我们就必需同时提到另一个概念”数据库“；当今时代数据爆炸，面对巨额的数据，我们创造了数据库这个在线的结构来处理，管理这些数据。而SQL就是一种结构化的数据库操作语言，它使得我们能够高效，准确的获取，修改，操作数据库中我们需要的数据。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;0x01sql基本处理与对应语法&#34;&gt;0x01：SQL基本处理与对应语法 &lt;a href=&#34;#0x01sql%e5%9f%ba%e6%9c%ac%e5%a4%84%e7%90%86%e4%b8%8e%e5%af%b9%e5%ba%94%e8%af%ad%e6%b3%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;从上一个部分，我们可以把SQL分成以下几个部分&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;1.DDL(Data Definition Language)数据定义语言，用来定义数据库对象(库 表 列&amp;hellip;)&lt;/p&gt;&#xA;&lt;p&gt;2.DML(Data Manipulation Language)数据操作语言，用来操作数据库中的数据&lt;/p&gt;&#xA;&lt;p&gt;3.DCL(Data Control Language)数据控制语言，定义数据权限与安全问题&lt;/p&gt;&#xA;&lt;p&gt;4.DQL（Data Query Language）数据查询语言，查询数据&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;我们一个一个来讲讲基本语法&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;以下语法句子中关键字均采取大写处理&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1ddl&#34;&gt;1.DDL &lt;a href=&#34;#1ddl&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&#34;库操作&#34;&gt;库操作 &lt;a href=&#34;#%e5%ba%93%e6%93%8d%e4%bd%9c&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建数据库：&lt;code&gt;CREATE DATABASE NAME&lt;/code&gt;；e.g&lt;code&gt;CREATE DATABASE whustd&lt;/code&gt;，创建一个名为 whustd的数据库。如果这个数据已经存在，那么会报错。但是 &lt;code&gt;CREATE DATABASE IF NOT EXISTS whustd&lt;/code&gt;，在名为 whustd 的数据库不存在时创建该库，这样可以避免报错。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;删除数据库：&lt;code&gt;DROP DATABASE [IF EXISTS] NAME&lt;/code&gt;；e.g DROP DATABASE &#x9; whustd，删除名为 WHUSTD 的数据库。如果这个数据库不存在，那么会报错。同理 &lt;code&gt;DROP DATABASE IF EXISTS WHUSTD&lt;/code&gt;，就算 WHUSTD不存在，也不会的报错。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;修改数据库编码：&lt;code&gt;ALTER DATABASE whustd CHARACTER SET utf8&lt;/code&gt;&#xA;修改数据库 WHUSTD 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都&#xA;不能使用中间的&lt;code&gt;“-”&lt;/code&gt;，即 UTF-8 要书写为 UTF8。&#xA;修改编码一般是处理非英文内容的编译防止出现乱码。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
